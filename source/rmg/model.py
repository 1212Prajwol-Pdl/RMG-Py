#!/usr/bin/python
# -*- coding: utf-8 -*-

################################################################################
#
#	RMG - Reaction Mechanism Generator
#
#	Copyright (c) 2002-2009 Prof. William H. Green (whgreen@mit.edu) and the
#	RMG Team (rmg_dev@mit.edu)
#
#	Permission is hereby granted, free of charge, to any person obtaining a
#	copy of this software and associated documentation files (the 'Software'),
#	to deal in the Software without restriction, including without limitation
#	the rights to use, copy, modify, merge, publish, distribute, sublicense,
#	and/or sell copies of the Software, and to permit persons to whom the
#	Software is furnished to do so, subject to the following conditions:
#
#	The above copyright notice and this permission notice shall be included in
#	all copies or substantial portions of the Software.
#
#	THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#	DEALINGS IN THE SOFTWARE.
#
################################################################################

"""
Contains classes for working with the reaction model generated by RMG.
"""

import logging
import quantities as pq
import numpy
import scipy.integrate

import reaction

################################################################################

class ReactionModel:
	"""
	Represent a generic reaction model. A reaction model consists of `species`,
	a list of species, and `reactions`, a list of reactions.
	"""	

	def __init__(self, species=None, reactions=None):
		self.species = species or []
		self.reactions = reactions or []

################################################################################

class CoreEdgeReactionModel:
	"""
	Represent a reaction model constructed using a rate-based screening
	algorithm. The `core` is a reaction model that represents species and 
	reactions currently in the model, while the `edge` is a reaction model that
	represents species and reactions identified as candidates for addition to 
	the core.
	"""	

	def __init__(self, core=None, edge=None):
		if core is None:
			self.core = ReactionModel()
		else:
			self.core = core
		if edge is None:
			self.edge = ReactionModel()
		else:
			self.edge = edge

	def initialize(self, coreSpecies):
		"""
		Initialize a reaction model with a list `coreSpecies` of species to
		start out with.
		"""

		logging.info('')
		
		for species1 in coreSpecies:
			# Generate reactions if reactive
			rxnList = []
			if species1.reactive:
				# Generate unimolecular reactions
				rxnList.extend(reaction.kineticsDatabase.getReactions([species1]))
				# Generate bimolecular reactions
				for species2 in self.core.species:
					rxnList.extend(reaction.kineticsDatabase.getReactions([species1, species2]))
			# Add to core
			self.addSpeciesToCore(species1)
			# Add to edge
			for rxn in rxnList:
				for spec in rxn.reactants:
					if spec not in self.edge.species:
						self.addSpeciesToEdge(spec)
				for spec in rxn.products:
					if spec not in self.edge.species:
						self.addSpeciesToEdge(spec)
				self.addReactionToEdge(rxn)

		logging.info('')
		logging.info('After core-edge reaction model initialization:')
		logging.info('\tThe model core has %s species and %s reactions' % (len(self.core.species), len(self.core.reactions)))
		logging.info('\tThe model edge has %s species and %s reactions' % (len(self.edge.species), len(self.edge.reactions)))

		# We cannot conduct simulations without having at least one reaction
		# in the core because otherwise we have no basis for selecting the
		# characteristic flux needed to test for model validity; thus we must
		# enlarge the reaction model until at least one reaction is in the core
		#while len(self.core.reactions) == 0:
		#	self.enlarge()

	def addSpeciesToCore(self, spec):
		"""
		Add a species `spec` to the reaction model core (and remove from edge if
		necessary). This function also moves any reactions in the edge that gain
		core status as a result of this change in status to the core.
		"""

		# Add the species to the core
		self.core.species.append(spec)

		if spec in self.edge.species:

			# If species was in edge, remove it
			self.edge.species.remove(spec)

			# Search edge for reactions that now contain only core species;
			# these belong in the model core and will be moved there
			rxnList = []
			for rxn in self.edge.reactions:
				allCore = True
				for reactant in rxn.reactants:
					if reactant not in self.core.species: allCore = False
				for product in rxn.products:
					if product not in self.core.species: allCore = False
				if allCore: rxnList.append(rxn)

			# Move any identified reactions to the core
			for rxn in rxnList:
				self.addReactionToCore(rxn)


	def addSpeciesToEdge(self, spec):
		"""
		Add a species `spec` to the reaction model edge.
		"""
		self.edge.species.append(spec)

	def addReactionToCore(self, rxn):
		"""
		Add a reaction `rxn` to the reaction model core (and remove from edge if
		necessary). This function assumes `rxn` has already been checked to
		ensure it is supposed to be a core reaction (i.e. all of its reactants
		AND all of its products are in the list of core species).
		"""
		self.core.reactions.append(rxn)
		if rxn in self.edge.reactions:
			self.edge.reactions.remove(rxn)

	def addReactionToEdge(self, rxn):
		"""
		Add a reaction `rxn` to the reaction model edge. This function assumes
		`rxn` has already been checked to ensure it is supposed to be an edge
		reaction (i.e. all of its reactants OR all of its products are in the
		list of core species, and the others are in either the core or the
		edge).
		"""
		self.edge.reactions.append(rxn)

################################################################################

class TemperatureModel:
	"""
	Represent a temperature profile. Currently the only implemented model is
	isothermal (constant temperature).
	"""

	def __init__(self):
		self.type = ''
		self.temperatures = []
		
	def isIsothermal(self):
		return self.type == 'isothermal'
	
	def setIsothermal(self, temperature):
		self.type = 'isothermal'
		self.temperatures = [ [0.0, temperature] ]
	
	def getTemperature(self, time):
		if self.isIsothermal():
			return self.temperatures[0][1]
		else:
			return None
	
	def __str__(self):
		string = 'Temperature model: ' + self.type + ' '
		if self.isIsothermal():
			string += str(self.getTemperature(0))
		return string
	
################################################################################

class PressureModel:
	"""
	Represent a pressure profile. Currently the only implemented model is
	isobaric (constant pressure).
	"""
	
	def __init__(self):
		self.type = ''
		self.pressures = []
		
	def isIsobaric(self):
		return self.type == 'isobaric'
	
	def setIsobaric(self, pressure):
		self.type = 'isobaric'
		self.pressures = [ [0.0, pressure] ]
	
	def getPressure(self, time):
		if self.isIsobaric():
			return self.pressures[0][1]
		else:
			return None

	def __str__(self):
		string = 'Pressure model: ' + self.type + ' '
		if self.isIsobaric():
			string += str(self.getPressure(0))
		return string

################################################################################

class IdealGas:
	"""
	An equation of state based on the ideal gas approximation

	.. math::

		f(P, V, T, \\mathbf{N}) = NRT - PV

	where :math:`N \\equiv \\sum_i N_i` is the total number of moles.

	The ideal gas approximation is generally valid for gases at low pressures
	and moderate tempertaures; it does not predict the gas-liquid phase
	transition and is not applicable to liquids.
	"""

	def getTemperature(self, P, V, N):
		"""
		Return the temperature associated with pressure `P`, volume `V`, and
		numbers of moles `N`.
		"""
		return (P * V / (sum(N) * pq.constants.R)).simplified()

	def getPressure(self, T, V, N):
		"""
		Return the temperature associated with temperature `T`, volume `V`, and
		numbers of moles `N`.
		"""
		return (sum(N) * pq.constants.R * T / V).simplified()

	def getVolume(self, T, P, N):
		"""
		Return the volume associated with temperature `T`, pressure `P`, and
		numbers of moles `N`.
		"""
		return (sum(N) * pq.constants.R * T / P).simplified()

	def getdPdV(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dP}{dV}\\bigg|_{T,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return (-P/V)

	def getdPdT(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dP}{dT}\\bigg|_{V,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return (P/T)

	def getdVdT(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dV}{dT}\\bigg|_{P,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return (V/T)

	def getdVdP(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dV}{dP}\\bigg|_{T,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return 1.0 / self.getdPdV(P, V, T, N)

	def getdTdP(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dT}{dP}\\bigg|_{V,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return 1.0 / self.getdPdT(P, V, T, N)

	def getdTdV(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dT}{dV}\\bigg|_{P,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return 1.0 / self.getdVdT(P, V, T, N)

	def getdPdNi(self, P, V, T, N, i):
		"""
		Return the derivative :math:`\\frac{dP}{dN_i}\\bigg|_{T, V,\mathbf{N}_{j \\ne i}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`. The final parameter `i` is used to determine which
		species to use; if `N` is a list, then `i` is an index, while if `N` is
		a dictionary, `i` is a key.
		"""
		if type(N) is dict: return (P/numpy.sum(N.values()))
		else: return (P/numpy.sum(N))

	def getdVdNi(self, P, V, T, N, i):
		"""
		Return the derivative :math:`\\frac{dV}{dN_i}\\bigg|_{T, P,\mathbf{N}_{j \\ne i}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`. The final parameter `i` is the index of the
		species of interest, corresponding to an index into the list `N`.
		"""
		if type(N) is dict: return (V/numpy.sum(N.values()))
		else: return (V/numpy.sum(N))

	def getdTdNi(self, P, V, T, N, i):
		"""
		Return the derivative :math:`\\frac{dT}{dN_i}\\bigg|_{P, V,\mathbf{N}_{j \\ne i}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`. The final parameter `i` is the index of the
		species of interest, corresponding to an index into the list `N`.
		"""
		if type(N) is dict: return (-T/numpy.sum(N.values()))
		else: return (-T/numpy.sum(N))

################################################################################

class InvalidReactionSystemException(Exception):
	"""
	An exception used when an invalid reaction system is encountered.
	"""

	def __init__(self, label):
		self.label = label

	def __str__(self):
		return 'Invalid reaction system: ' + self.label

################################################################################

class ReactionSystem:
	"""
	Represent a generic reaction system, e.g. a chemical reactor. A reaction
	system is defined by a temperature model `temperatureModel`, a pressure 
	model `pressureModel`, a volume model `volumeModel`, and a dictionary of 
	initial and constant concentrations `initialConcentration`. Only two of
	`temperatureModel`, `pressureModel`, and `volumeModel` are independent; the
	remaining one must be set to :data:`None`.

	Each RMG job can handle multiple reaction systems; the resulting model
	will generally be the union of the models that would have been generated 
	via individual RMG jobs, and will therefore be valid across all reaction
	systems provided.	
	"""

	def __init__(self, temperatureModel=None, pressureModel=None, 
				 volumeModel=None, initialConcentration=None):
		self.setModels(temperatureModel, pressureModel, volumeModel)
		self.initialConcentration = initialConcentration or {}

	def setModels(self, temperatureModel, pressureModel, volumeModel):
		"""
		Set any two of the reactor's `temperatureModel`, `pressureModel` or
		`volumeModel`. Attempting to set all three to non-None will cause an
		:class:`InvalidReactorModelException` to be raised.
		"""
		# Fail if all three models are specified
		if temperatureModel is not None and pressureModel is not None and volumeModel is not None:
			raise InvalidReactionSystemException('Attempted to specify temperature, pressure, and volume models; can only specify two of these at a time.')
		# Otherwise set models
		self.temperatureModel = temperatureModel
		self.pressureModel = pressureModel
		self.volumeModel = volumeModel

################################################################################

class BatchReactor(ReactionSystem):
	"""
	A model of a batch reactor. A batch reactor is a well-mixed system with
	no external inputs or output, so all transport effects can be neglected.
	Any two of a temperature model, pressure model, and volume model can be
	specified; the remaining one is dependent on the choice of the other two.
	"""

	def __init__(self, temperatureModel=None, pressureModel=None, \
				 volumeModel=None, initialConcentration=None):
		ReactionSystem.__init__(self, temperatureModel, pressureModel, \
				volumeModel, initialConcentration)

	def getResidual(self, t, y, species, reactions, speciesIndex):
		"""
		Return the residual function for this reactor model, evaluated at
		time `t` and values of the dependent variables `y`. The residual
		function is the right-hand side of the equation

		.. math:: \\frac{d \\mathbf{y}}{dt} = \\mathbf{R}(\\mathbf{y})

		The dependent variables include temperature, pressure, volume, and
		numbers of moles for each species.
		"""

		# Convert dependent variables to a more meaningful representation
		P = pq.Quantity(y[0], 'Pa')
		V = pq.Quantity(y[1], 'm**3')
		T = pq.Quantity(y[2], 'K')
		Ni = pq.Quantity(y[3:], 'mol')
		
		# Determine intermediate/helper variables
		Ci = {}
		for i, N in enumerate(Ni):
			Ci[speciesIndex[i]] = N / V
		
		# Species balances
		dNidt = {}
		for spec in species:
			dNidt[spec] = reactions[0].getStoichiometricCoefficient(spec) * reactions[0].getRate(T, P, Ci) * V
			for rxn in reactions[1:]:
				dNidt[spec] = dNidt[spec] + rxn.getStoichiometricCoefficient(spec) * rxn.getRate(T, P, Ci) * V
		
		# Energy balance (assume isothermal for now)
		dTdt = pq.Quantity(0.0, 'K/s')

		# Pressure balance (assume isobaric for now)
		dPdt = pq.Quantity(0.0, 'Pa/s')

		# Volume balance comes from equation of state
		dVdP = self.equationOfState.getdVdP(P, V, T, Ni)
		dVdT = self.equationOfState.getdVdT(P, V, T, Ni)
		dVdNi = {}
		for i in range(len(Ni)):
			dVdNi[speciesIndex[i]] = self.equationOfState.getdVdNi(P, V, T, Ni, i)

		# Quantities bug prevents this from working, so bypass for now
#		dVdt = dVdP * dPdt + dVdT * dTdt
#		for spec in dVdNi:
#			dVdt += dVdNi[spec] * dNidt[spec]
		dVdt = float(dVdP * dPdt + dVdT * dTdt)
		for spec in dVdNi:
			dVdt += float(dVdNi[spec] * dNidt[spec])

		# Convert derivatives to residual
		dydt = [0 for i in range(len(dNidt)+3)]
		dydt[0] = dPdt
		dydt[1] = dVdt
		dydt[2] = dTdt
		for spec in dNidt:
			index = speciesIndex.index(spec)
			dydt[index+3] = dNidt[spec]
		
		# Return residual
		return dydt

	def solve(self, t0, tf, species, reactions):

		modelValid = True

		# Map species to indices
		speciesIndex = []
		for spec in species:
			speciesIndex.append(spec)

		# Set up initial conditions
		P = self.pressureModel.getPressure(0)
		T = self.temperatureModel.getTemperature(0)
		V = pq.Quantity(1.0, 'm**3')
		Ni = [0 for spec in species]
		for spec in species:
			index = speciesIndex.index(spec)
			if spec in self.initialConcentration:
				Ni[index] = self.initialConcentration[spec] * V
			else:
				Ni[index] = 0.0
		y0 = [P, V, T]; y0.extend(Ni)

		# Set up solver
		solver = scipy.integrate.ode(self.getResidual,None)
		solver.set_integrator('vode', method='bdf', with_jacobian=False)
		solver.set_f_params(species, reactions, speciesIndex)
		solver.set_initial_value(y0,t0)

		dt = (tf - t0) / 100.0
		while solver.successful() and solver.t < tf and modelValid:
			solver.integrate(solver.t + dt)
			print solver.t, solver.y


################################################################################

if __name__ == '__main__':

	import chem
	import data
	import species
	import reaction

	import os.path
	import main
	main.initializeLog(logging.DEBUG)

	datapath = '../data/RMG_database/'

	logging.debug('General database: ' + os.path.abspath(datapath))
	species.thermoDatabase = species.ThermoDatabaseSet()
	species.thermoDatabase.load(datapath)
	species.forbiddenStructures = data.Dictionary()
	species.forbiddenStructures.load(datapath + 'forbiddenStructure.txt')
	species.forbiddenStructures.toStructure()
	#reaction.kineticsDatabase = reaction.ReactionFamilySet()
	#reaction.kineticsDatabase.load(datapath)

	structure = chem.Structure(); structure.fromSMILES('C')
	CH4 = species.makeNewSpecies(structure)

	structure = chem.Structure(); structure.fromSMILES('[H]')
	H = species.makeNewSpecies(structure)

	structure = chem.Structure(); structure.fromSMILES('[CH3]')
	CH3 = species.makeNewSpecies(structure)

	forward = reaction.Reaction([CH3, H], [CH4])
	reverse = reaction.Reaction([CH4], [CH3, H])
	forward.reverse = reverse
	reverse.reverse = forward

	kinetics = reaction.ArrheniusEPKinetics()
	kinetics.fromDatabase([300, 2000, 1.93E14, 0, 0, 0.27, 0, 0, 0, 0, 3], '', 2)
	forward.kinetics = [kinetics]

	speciesList = [CH3, H, CH4]
	reactionList = [forward]

	reactionSystem = BatchReactor()
	reactionSystem.temperatureModel = TemperatureModel()
	reactionSystem.temperatureModel.setIsothermal(pq.Quantity(1000, 'K'))
	reactionSystem.pressureModel = PressureModel()
	reactionSystem.pressureModel.setIsobaric(pq.Quantity(1, 'bar'))
	reactionSystem.equationOfState = IdealGas()
	reactionSystem.initialConcentration[CH4] = pq.Quantity(1, 'mol/m**3')

	reactionSystem.solve(0.0, 1.0e0, speciesList, reactionList)
	
	