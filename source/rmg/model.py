#!/usr/bin/python
# -*- coding: utf-8 -*-

################################################################################
#
#	RMG - Reaction Mechanism Generator
#
#	Copyright (c) 2002-2009 Prof. William H. Green (whgreen@mit.edu) and the
#	RMG Team (rmg_dev@mit.edu)
#
#	Permission is hereby granted, free of charge, to any person obtaining a
#	copy of this software and associated documentation files (the 'Software'),
#	to deal in the Software without restriction, including without limitation
#	the rights to use, copy, modify, merge, publish, distribute, sublicense,
#	and/or sell copies of the Software, and to permit persons to whom the
#	Software is furnished to do so, subject to the following conditions:
#
#	The above copyright notice and this permission notice shall be included in
#	all copies or substantial portions of the Software.
#
#	THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#	DEALINGS IN THE SOFTWARE.
#
################################################################################

"""
Contains classes for working with the reaction model generated by RMG.
"""

import logging
import math
import numpy
import scipy.integrate

import constants
import settings
import reaction

import ctml_writer
import os

################################################################################

class ReactionModel:
	"""
	Represent a generic reaction model. A reaction model consists of `species`,
	a list of species, and `reactions`, a list of reactions.
	"""	

	def __init__(self, species=None, reactions=None):
		self.species = species or []
		self.reactions = reactions or []

################################################################################

class CoreEdgeReactionModel:
	"""
	Represent a reaction model constructed using a rate-based screening
	algorithm. The `core` is a reaction model that represents species and 
	reactions currently in the model, while the `edge` is a reaction model that
	represents species and reactions identified as candidates for addition to 
	the core.
	"""	
	
	def __init__(self, core=None, edge=None):
		if core is None:
			self.core = ReactionModel()
		else:
			self.core = core
		if edge is None:
			self.edge = ReactionModel()
		else:
			self.edge = edge
		self.fluxTolerance_keep_in_edge = 0.0
		self.fluxTolerance_move_to_core = 1.0
		self.fluxTolerance_interrupt_simulation = 1.0
		self.absoluteTolerance = 1.0e-8
		self.relativeTolerance = 1.0e-4
		self.termination = []

	def initialize(self, coreSpecies):
		"""
		Initialize a reaction model with a list `coreSpecies` of species to
		start out with.
		"""

		logging.info('')
		
		# Add all species present in input file to model core
		for spec in coreSpecies:
			self.enlarge(spec)

	def enlarge(self, newSpecies):
		"""
		Enlarge a reaction model by moving `newSpecies` from the edge to the
		core.
		"""

		rxnList = []
		# Find reactions involving the new species as unimolecular reactant or
		# product (e.g. A <---> products)
		rxnList.extend(reaction.kineticsDatabase.getReactions([newSpecies]))
		# Find reactions involving the new species as bimolecular reactants or
		# products with itself (e.g. A + A <---> products)
		rxnList.extend(reaction.kineticsDatabase.getReactions([newSpecies, newSpecies]))
		# Find reactions involving the new species as bimolecular reactants or
		# products with other core species (e.g. A + B <---> products)
		for coreSpecies in self.core.species:
			if coreSpecies.reactive:
				rxnList.extend(reaction.kineticsDatabase.getReactions([newSpecies, coreSpecies]))
		
		# Add new species
		self.addSpeciesToCore(newSpecies)
		
		# Add new reactions
		for rxn in rxnList:
			allSpeciesInCore = True
			for spec in rxn.reactants:
				if spec not in self.core.species: allSpeciesInCore = False
				if spec not in self.edge.species and spec not in self.core.species:
					self.addSpeciesToEdge(spec)
			for spec in rxn.products:
				if spec not in self.core.species: allSpeciesInCore = False
				if spec not in self.edge.species and spec not in self.core.species:
					self.addSpeciesToEdge(spec)
			if allSpeciesInCore:
				self.addReactionToCore(rxn)
			else:
				self.addReactionToEdge(rxn)
		
		logging.info('')
		logging.info('After model enlargement:')
		logging.info('\tThe model core has %s species and %s reactions' % (len(self.core.species), len(self.core.reactions)))
		logging.info('\tThe model edge has %s species and %s reactions' % (len(self.edge.species), len(self.edge.reactions)))
		logging.info('')

	def addSpeciesToCore(self, spec):
		"""
		Add a species `spec` to the reaction model core (and remove from edge if
		necessary). This function also moves any reactions in the edge that gain
		core status as a result of this change in status to the core.
		"""
		
		# Add the species to the core
		self.core.species.append(spec)
		
		# Add it to the cantera list
		spec.toCantera()
		
		if spec in self.edge.species:
			
			# If species was in edge, remove it
			self.edge.species.remove(spec)
			
			# Search edge for reactions that now contain only core species;
			# these belong in the model core and will be moved there
			rxnList = []
			for rxn in self.edge.reactions:
				allCore = True
				for reactant in rxn.reactants:
					if reactant not in self.core.species: allCore = False
				for product in rxn.products:
					if product not in self.core.species: allCore = False
				if allCore: rxnList.append(rxn)
				
			# Move any identified reactions to the core
			for rxn in rxnList:
				self.addReactionToCore(rxn)
	
	def addSpeciesToEdge(self, spec):
		"""
		Add a species `spec` to the reaction model edge.
		"""
		self.edge.species.append(spec)
	
	def removeSpeciesFromEdge(self, spec):
		"""
		Add a species `spec` to the reaction model edge.
		"""
		# remove the species
		self.edge.species.remove(spec)
		# identify any reactions it's involved in
		rxnList = []
		for rxn in self.edge.reactions:
			if spec not in rxn.reactants and spec not in rxn.products:
				rxnList.append(rxn)
		# remove those reactions
		self.edge.reactions.remove(rxn)
	
	def addReactionToCore(self, rxn):
		"""
		Add a reaction `rxn` to the reaction model core (and remove from edge if
		necessary). This function assumes `rxn` has already been checked to
		ensure it is supposed to be a core reaction (i.e. all of its reactants
		AND all of its products are in the list of core species).
		"""
		self.core.reactions.append(rxn)
		if rxn in self.edge.reactions:
			self.edge.reactions.remove(rxn)
		
		# add it to the Cantera list
		rxn.toCantera()
	
	def addReactionToEdge(self, rxn):
		"""
		Add a reaction `rxn` to the reaction model edge. This function assumes
		`rxn` has already been checked to ensure it is supposed to be an edge
		reaction (i.e. all of its reactants OR all of its products are in the
		list of core species, and the others are in either the core or the
		edge).
		"""
		self.edge.reactions.append(rxn)
	
	def getLists(self):
		"""
		Return lists of all of the species and reactions in the core and the
		edge.
		"""
		speciesList = []
		speciesList.extend(self.core.species)
		speciesList.extend(self.edge.species)
		reactionList = []
		reactionList.extend(self.core.reactions)
		reactionList.extend(self.edge.reactions)
		return speciesList, reactionList
	
	def getStoichiometryMatrix(self):
		"""
		Return the stoichiometry matrix for all core and edge species. The
		rows represent the species in the core and edge in order, while the
		columns represent the reactions in the core and edge in order.
		"""
		speciesList, reactionList = self.getLists()
		stoichiometry = numpy.zeros((len(speciesList), len(reactionList)), float)
		for j, rxn in enumerate(reactionList):
			for i, spec in enumerate(speciesList):
				stoichiometry[i,j] = rxn.getStoichiometricCoefficient(spec)
		return stoichiometry
	
	def getReactionRates(self, T, P, Ci):
		"""
		Return an array of reaction rates for each reaction in the model core
		and edge. The core reactions occupy the first rows of the array, while
		the edge reactions occupy the last rows.
		"""
		speciesList, reactionList = self.getLists()
		rxnRate = numpy.zeros(len(reactionList), float)
		totalConc = sum( Ci.values() )
		for j, rxn in enumerate(reactionList):
			rxnRate[j] = rxn.getRate(T, P, Ci, totalConc)
		return rxnRate

################################################################################

class TemperatureModel:
	"""
	Represent a temperature profile. Currently the only implemented model is
	isothermal (constant temperature).
	"""

	def __init__(self):
		self.type = ''
		self.temperatures = []
		
	def isIsothermal(self):
		return self.type == 'isothermal'
	
	def setIsothermal(self, temperature):
		self.type = 'isothermal'
		self.temperatures = [ [0.0, temperature] ]
	
	def getTemperature(self, time=None):
		if self.isIsothermal():
			return self.temperatures[0][1]
		else:
			return None
	
	def __str__(self):
		string = 'Temperature model: ' + self.type + ' '
		if self.isIsothermal():
			string += str(self.getTemperature(0))
		return string
	
################################################################################

class PressureModel:
	"""
	Represent a pressure profile. Currently the only implemented model is
	isobaric (constant pressure).
	"""
	
	def __init__(self):
		self.type = ''
		self.pressures = []
		
	def isIsobaric(self):
		return self.type == 'isobaric'
	
	def setIsobaric(self, pressure):
		self.type = 'isobaric'
		self.pressures = [ [0.0, pressure] ]
	
	def getPressure(self, time=None):
		if self.isIsobaric():
			return self.pressures[0][1]
		else:
			return None

	def __str__(self):
		string = 'Pressure model: ' + self.type + ' '
		if self.isIsobaric():
			string += str(self.getPressure(0))
		return string

################################################################################

class IdealGas:
	"""
	An equation of state based on the ideal gas approximation

	.. math::

		f(P, V, T, \\mathbf{N}) = NRT - PV

	where :math:`N \\equiv \\sum_i N_i` is the total number of moles.

	The ideal gas approximation is generally valid for gases at low pressures
	and moderate tempertaures; it does not predict the gas-liquid phase
	transition and is not applicable to liquids.
	"""

	def getTemperature(self, P, V, N):
		"""
		Return the temperature associated with pressure `P`, volume `V`, and
		numbers of moles `N`.
		"""
		return P * V / (sum(N) * constants.R)

	def getPressure(self, T, V, N):
		"""
		Return the pressure associated with temperature `T`, volume `V`, and
		numbers of moles `N`.
		"""
		return sum(N) * constants.R * T / V

	def getVolume(self, T, P, N):
		"""
		Return the volume associated with temperature `T`, pressure `P`, and
		numbers of moles `N` (which may be a list, in which case it's summed).
		"""
		try:
		    N = sum(N)
		except TypeError: #can't iterate; N probably a float not a list
		    pass
		return N * constants.R * T / P

	def getdPdV(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dP}{dV}\\big|_{T,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return (-P/V)

	def getdPdT(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dP}{dT}\\big|_{V,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return (P/T)

	def getdVdT(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dV}{dT}\\big|_{P,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return (V/T)

	def getdVdP(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dV}{dP}\\big|_{T,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return 1.0 / self.getdPdV(P, V, T, N)

	def getdTdP(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dT}{dP}\\big|_{V,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return 1.0 / self.getdPdT(P, V, T, N)

	def getdTdV(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dT}{dV}\\big|_{P,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return 1.0 / self.getdVdT(P, V, T, N)

	def getdPdNi(self, P, V, T, N, i):
		"""
		Return the derivative :math:`\\frac{dP}{dN_i}\\big|_{T, V,\mathbf{N}_{j \\ne i}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`. The final parameter `i` is used to determine which
		species to use; if `N` is a list, then `i` is an index, while if `N` is
		a dictionary, `i` is a key.
		"""
		if type(N) is dict: return (P/numpy.sum(N.values()))
		else: return (P/numpy.sum(N))

	def getdVdNi(self, P, V, T, N, i):
		"""
		Return the derivative :math:`\\frac{dV}{dN_i}\\big|_{T, P,\mathbf{N}_{j \\ne i}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`. The final parameter `i` is the index of the
		species of interest, corresponding to an index into the list `N`.
		"""
		if type(N) is dict: return (V/numpy.sum(N.values()))
		else: return (V/numpy.sum(N))

	def getdTdNi(self, P, V, T, N, i):
		"""
		Return the derivative :math:`\\frac{dT}{dN_i}\\big|_{P, V,\mathbf{N}_{j \\ne i}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`. The final parameter `i` is the index of the
		species of interest, corresponding to an index into the list `N`.
		"""
		if type(N) is dict: return (-T/numpy.sum(N.values()))
		else: return (-T/numpy.sum(N))

################################################################################

class IncompressibleLiquid:
	"""
	An equation of state for incompressible liquids

	.. math:: f(P, V, T, \\mathbf{N}) = ?

	where :math:`N \\equiv \\sum_i N_i` is the total number of moles.

	Initialise with keyword arguments::
		il = IncompressibleLiquid(T=298, P=1E5, V=, N=, Vmol=)
	"""
	def __init__(self, T=None, P=None, V=None, N=None, Vmol=None):
		self.T = T
		self.P = P
		self.V = V
		self.N = N
		self.Vmol = Vmol # Molar volume
		
	def getTemperature(self, P, V, N):
		"""
		Return the temperature associated with pressure `P`, volume `V`, and
		numbers of moles `N`.
		"""
		if self.T: 
			return self.T
		else:
			raise Exception("I'm a liquid, and can't deduce T from P,V,N.")

	def getPressure(self, T, V, N):
		"""
		Return the pressure associated with temperature `T`, volume `V`, and
		numbers of moles `N`.
		"""
		if self.P:
			return self.P
		else:
			raise Exception("I'm a liquid, and can't deduce P from T,V,N.")
		
	def getVolume(self, T, P, N):
		"""
		Return the volume associated with temperature `T`, pressure `P`, and
		numbers of moles `N` (which may be a list, in which case it's summed).
		"""
		if self.V:
			logging.debug("Using explicit volume.")
			return self.V
		try:
		    N = sum(N)
		except TypeError: #can't iterate; N probably a float not a list
		    pass
		if self.Vmol:
			return N * self.Vmol
		else:
			raise Exception("I'm a liquid with unknown molarVolume, and can't deduce V from T,P,N.")
		
	def getdPdV(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dP}{dV}\\big|_{T,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return  0

	def getdPdT(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dP}{dT}\\big|_{V,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return 0

	def getdVdT(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dV}{dT}\\big|_{P,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return 0

	def getdVdP(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dV}{dP}\\big|_{T,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return 0

	def getdTdP(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dT}{dP}\\bigg|_{V,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return 0

	def getdTdV(self, P, V, T, N):
		"""
		Return the derivative :math:`\\frac{dT}{dV}\\big|_{P,\mathbf{N}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`.
		"""
		return 0

	def getdPdNi(self, P, V, T, N, i):
		"""
		Return the derivative :math:`\\frac{dP}{dN_i}\\big|_{T, V,\mathbf{N}_{j \\ne i}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`. The final parameter `i` is used to determine which
		species to use; if `N` is a list, then `i` is an index, while if `N` is
		a dictionary, `i` is a key.
		"""
		return numpy.inf
		### Warning: may be inconsistent with dVdNi and dVdP
		## if dVdNi>0 and dVdP=0 then is'nt dPdNi = infinity ?
		
	def getdTdNi(self, P, V, T, N, i):
		"""
		Return the derivative :math:`\\frac{dT}{dN_i}\\big|_{P, V,\mathbf{N}_{j \\ne i}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`. The final parameter `i` is the index of the
		species of interest, corresponding to an index into the list `N`.
		"""
		return 0
		
	def getdVdNi(self, P, V, T, N, i):
		"""
		Return the derivative :math:`\\frac{dV}{dN_i}\\big|_{T, P,\mathbf{N}_{j \\ne i}}`
		evaluated at a given pressure `P`, volume `V`, temperature `T`, and
		numbers of moles `N`. The final parameter `i` is the index of the
		species of interest, corresponding to an index into the list `N`.
		
		For lack of better information,
		we assume that the partial molar volume of species `i`
		is equal to the average molar volume of the mixture as a whole.
		"""
		
		if self.Vmol: # molar volume is set; assume it's the same for all components, and use it
			return self.Vmol 
			
		# Else assume that the partial molar volume of species i
		# is equal to the average molar volume of all species
		if type(N) is dict: return (V/numpy.sum(N.values()))
		else: return (V/numpy.sum(N))



################################################################################

class InvalidReactionSystemException(Exception):
	"""
	An exception used when an invalid reaction system is encountered.
	"""

	def __init__(self, label):
		self.label = label

	def __str__(self):
		return 'Invalid reaction system: ' + self.label

################################################################################
class FakeSolver:
	"""Used as a dummy solver, to contain t etc."""
	def __init__(self):
		self.t = 0
		self.y = None
	def successful(self):
		return True # how can I fail?
	
class ReactionSystem:
	"""
	Represent a generic reaction system, e.g. a chemical reactor. A reaction
	system is defined by a temperature model `temperatureModel`, a pressure 
	model `pressureModel`, a volume model `volumeModel`, and a dictionary of 
	initial and constant concentrations `initialConcentration`. Only two of
	`temperatureModel`, `pressureModel`, and `volumeModel` are independent; the
	remaining one must be set to :data:`None`.

	Each RMG job can handle multiple reaction systems; the resulting model
	will generally be the union of the models that would have been generated 
	via individual RMG jobs, and will therefore be valid across all reaction
	systems provided.	
	"""

	def __init__(self, temperatureModel=None, pressureModel=None, 
				 volumeModel=None, initialConcentration=None):
		self.setModels(temperatureModel, pressureModel, volumeModel)
		self.initialConcentration = initialConcentration or {}

	def setModels(self, temperatureModel, pressureModel, volumeModel):
		"""
		Set any two of the reactor's `temperatureModel`, `pressureModel` or
		`volumeModel`. Attempting to set all three to non-None will cause an
		:class:`InvalidReactorModelException` to be raised.
		"""
		# Fail if all three models are specified
		if temperatureModel is not None and pressureModel is not None and volumeModel is not None:
			raise InvalidReactionSystemException('Attempted to specify temperature, pressure, and volume models; can only specify two of these at a time.')
		# Otherwise set models
		self.temperatureModel = temperatureModel
		self.pressureModel = pressureModel
		self.volumeModel = volumeModel

################################################################################

class BatchReactor(ReactionSystem):
	"""
	A model of a batch reactor. A batch reactor is a well-mixed system with
	no external inputs or output, so all transport effects can be neglected.
	Any two of a temperature model, pressure model, and volume model can be
	specified; the remaining one is dependent on the choice of the other two.
	"""

	def __init__(self, temperatureModel=None, pressureModel=None, \
				 volumeModel=None, initialConcentration=None):
		ReactionSystem.__init__(self, temperatureModel, pressureModel, \
				volumeModel, initialConcentration)
		
		self.toCantera()

	
	def toCantera(self):
		"""Creata a Cantera instance. Call this once"""
		ctml_writer.units(length = "m", time = "s", quantity = "mol", act_energy = "J/mol")
		phase = ctml_writer.ideal_gas(name = "chem",
		      elements = " C H O N Ar He Si",
		      species = "all",
		      reactions = "all",
		      initial_state = ctml_writer.state(temperature = 1000 ,
		                        pressure = 101325 )    )
		def has_species(sp):
			"""Return 1 is a species with name 's' belongs to the phase,
			or 0 otherwise. Redefined because the ctml_writer one doesn't work for us"""
			if sp in ctml_writer._speciesnames: return 1
			return 0
		phase.has_species = has_species
		#self._cantera = phase  # if we save it, we have to pickle it, and we can't pickle the has_species function
		ctml_writer.validate() # turns on validation
	
	def getResidual(self, t, y, model, stoichiometry):
		"""
		Return the residual function for this reactor model, evaluated at
		time `t` and values of the dependent variables `y`. The residual
		function is the right-hand side of the equation

		.. math:: \\frac{d \\mathbf{y}}{dt} = \\mathbf{R}(\\mathbf{y})

		The dependent variables are temperature, pressure, volume, and
		numbers of moles for each species.
		
		.. math:: \\mathbf{y} \\equiv \\left[ P, V, T, N_1, N_2,\\ldots, N_i \\right]
		
		Currently only models isothermal and isobaric reactors (:math:`dT/dt=dP/dt=0`)
		"""

		P, V, T = y[0:3]; Ni = y[3:]
		
		# Get new thermo snapshots
		for spec in model.core.species:
			if not spec.thermoSnapshot.isValid(temperature=T):
				if spec.thermoData is None: spec.getThermoData()
				spec.thermoSnapshot.update(temperature=T, thermoData=spec.thermoData)
		
		# Reaction rates
		rxnRate = self.getReactionRates(P, V, T, Ni, model)
		
		# Species balances
		dNidt = numpy.dot(stoichiometry[0:len(model.core.species), 0:len(model.core.reactions)],
		 					rxnRate[0:len(model.core.reactions)])

		# Energy balance (assume isothermal for now)
		dTdt = 0.0

		# Pressure balance (assume isobaric for now)
		dPdt = 0.0

		# Volume balance comes from equation of state
		dVdP = self.equationOfState.getdVdP(P, V, T, Ni)
		dVdT = self.equationOfState.getdVdT(P, V, T, Ni)
		dVdNi = numpy.array([self.equationOfState.getdVdNi(P, V, T, Ni, i) for i in Ni])
		dVdt = dVdP * dPdt + dVdT * dTdt + numpy.dot(dVdNi, dNidt)
		
		# Convert derivatives to residual
		dydt = numpy.zeros(len(dNidt)+3, float)
		dydt[0] = dPdt
		dydt[1] = dVdt
		dydt[2] = dTdt
		dydt[3:] = dNidt

		# Return residual
		return dydt
		
	def getJacobian(self, t, y, model, stoichiometry):
		"""
		Return the Jacobian function for this reactor model, evaluated at
		time `t` and values of the dependent variables `y`. The Jacobean
		function is the right-hand side of the equation

		.. math:: something

		The dependent variables are temperature, pressure, volume, and
		numbers of moles for each species.
		
		.. math:: \\mathbf{y} \\equiv \\left[ P, V, T, N_1, N_2,\\ldots, N_i \\right]
		
		Currently only models isothermal and isobaric reactors (:math:`dT/dt=dP/dt=0`)
		"""
		P, V, T = y[0:3]; Ni = y[3:]
		raise NotImplementedError('Jacobian not implemented for batch reactor.')


	def getReactionRates(self, P, V, T, Ni, model):
		"""
		Evaluate the reaction rates for all reactions in the model (core and
		edge).
		"""
		Ci = {}
		for i, spec in enumerate(model.core.species):
			Ci[spec] = Ni[i] / V

		return model.getReactionRates(T, P, Ci)

	def getSpeciesFluxes(self, model, P, V, T, Ni, stoichiometry):
		"""
		Determine the species fluxes of all species in the model core and edge
		at the specified pressure `P`, volume `V`, temperature `T`, and numbers 
		of moles `Ni`. The `stoichiometry` parameter is the stoichiometry
		matrix for the model.
		"""
		rxnRates = self.getReactionRates(P, V, T, Ni, model)
		return numpy.dot(stoichiometry, rxnRates)

	def isModelValid(self, model, dNidt, criticalFlux):
		"""
		Returns :data:`True` if `model` is valid given the set of species fluxes
		`dNidt` and the critical flux `criticalFlux`.
		Also returns the edge species whose flux is greatest, and that flux.
		"""
		
		speciesList, reactionList = model.getLists()
		
		if len(model.edge.species) > 0:
			maxSpeciesFlux, maxSpecies = max([ (value, i+len(model.core.species)) for i, value in enumerate(dNidt[len(model.core.species):]) ])
			return (maxSpeciesFlux < criticalFlux), speciesList[maxSpecies], maxSpeciesFlux
		else:
			return True, None, 0.0


	def runCantera(self, model):
		"""Write a cantera file, read it in cantera, and return a ReactorNet and Solution"""
		
		# Write the cantera file to scratch/cantera/ folder
		cantera_folder = os.path.join(settings.scratchDirectory,'cantera')
		os.path.exists(cantera_folder) or os.mkdir(cantera_folder)
		cti_file = os.path.join(cantera_folder,'cantera_input_%03d'%len(model.core.species) )
		logging.debug("Writing CTML file %s"%cti_file)
		ctml_writer.dataset(cti_file) # change name
		
		ctml_writer.write()
		
		import Cantera
		import Cantera.Reactor
		
		logging.info("Preparing Cantera simulation %d"%len(model.core.species))
		Cantera.reset()
		gas = Cantera.importPhase(cti_file+'.xml','chem', loglevel=1)
		
		concentrations = numpy.zeros(len(model.core.species))
		for spec, conc in self.initialConcentration.iteritems():
			concentrations[gas.speciesIndex(str(spec))] = conc
		gas.setMoleFractions(concentrations) # it normalises it to 1
		
		gas.set( T = float(self.temperatureModel.getTemperature(0)),
		         P = float(self.pressureModel.getPressure(0)) )
		
		# create a batch reactor
		reactor = Cantera.Reactor.Reactor(gas, volume = 1.0)
			
		# set the inital environment conditions
		gasAir = Cantera.Air()
		gasAir.set(T=float(self.temperatureModel.getTemperature(0)), P=float(self.pressureModel.getPressure(0)))
		# create a reservoir for the environment
		environment = Cantera.Reactor.Reservoir(gasAir)
		# Define a wall between the reactor and the environment, and
		# make it flexible, so that the pressure in the reactor is held
		# at the environment pressure, and conductive so the temperature likewise
		wall = Cantera.Reactor.Wall(reactor,environment)
		wall.set(K = 1.0e12)   # set expansion parameter. dV/dt = KA(P_1 - P_2)
		wall.set(A = 1.0) # set wall area
		wall.setHeatTransferCoeff(1.0e15) # W/m2/K
		
		# put reactor in a reactor network so it can be integrated
		sim = Cantera.Reactor.ReactorNet([reactor])
		
		#import pdb; pdb.set_trace()
		return sim, gas
		

	def simulate(self, model):
		"""
		Conduct a simulation of the current reaction system using the core-edge
		reaction model `model`.
		
		Edge species fluxes are tracked, relative to the characteristic core 
		flux at that time, throughout the simulation. 
		If one exceeds `model.fluxTolerance_interruptSimulation` the simulation
		is interrupted, and that species is returned.
		The highest relative flux reached by each species during the simulation 
		is stored for later analysis.
		If one or more of these exceed `model.fluxTolerance_moveToCore` then the 
		species with the highest will be returned.
		
		If the simulation completes without interruption, then any that fall 
		below `model.fluxTolerance_keepInEdge` will be removed from the
		edge, along with the reactions that involve them.
		
		Returns:
		(tlist, ylist, dydtlist, valid?, Edge_species_with_highest_flux)
		"""
		
		# try writing cantera file
		sim,gas = self.runCantera(model)
		
		# Assemble stoichiometry matrix for all core and edge species
		# Rows are species (core, then edge); columns are reactions (core, then edge)
		stoichiometry = model.getStoichiometryMatrix()
		
		tlist = []; ylist = []; dydtlist = []
		maxRelativeFluxes = numpy.zeros(len(model.core.species) + len(model.edge.species), float)

		endtime = 10.0 # default. check for user value:
		for target in model.termination:
			if target.__class__ == TerminationTime:
				endtime = target.time
			
		# Set up initial conditions
		P = gas.pressure()
		V = sim.reactors()[0].volume()
		T = gas.temperature()
		# recall that Cantera returns molarDensity() in units of kmol/m3
		# and this program thinks in mol/m3
		Ni = gas.molarDensity()*1000.0 * gas.moleFractions() * V 
		y = [P, V, T]; y.extend(Ni)
		Ni0 = Ni
		y0 = y

#		# Output information about simulation at current time
		header = 'Time          '
		for target in model.termination:
			if target.__class__ == TerminationConversion: header += 'Conv        '
		header += 'Thresh. flux     Maximum flux to edge'
		logging.debug(header)
#		self.printSimulationStatus(model, 0, y, y0, criticalFlux, maxSpeciesFlux, maxSpecies)
#		tlist.append(0.0); ylist.append(y0)
#		dydtlist.append(self.getResidual(0.0, y0, model, stoichiometry))
		
		
		solver = FakeSolver()
		
		done = False
		first_step = True
		while not done and solver.successful():
			
			# Conduct integration
			if first_step: 
				first_step = False # don't integrate on first time through, just do the validity checking and result reporting
			else:
				# advance cantera one step, or two if the first didn't get there
				nexttime = time*1.2589254117941673
				if sim.step(endtime) < endtime:
				 	if sim.step(endtime) < nexttime:
						sim.advance(nexttime)
				
			time = sim.time()
			P = gas.pressure()
			V = sim.reactors()[0].volume()
			T = gas.temperature()
			# recall that Cantera returns molarDensity() in units of kmol/m3
			# and this program thinks in mol/m3
			Ni = gas.molarDensity()*1000.0 * gas.moleFractions() * V 
			solver.y = [P, V, T]; solver.y.extend(Ni)
			
			# Calculate species fluxes of all core and edge species at the
			# current time
			dNidt = self.getSpeciesFluxes(model, P, V, T, Ni, stoichiometry)
			
			# Determine characteristic species flux
			charFlux = math.sqrt(sum([x*x for x in dNidt[0:len(model.core.species)]]))
			
			# Store the highest relative flux for each species
			for i in range(len(dNidt)):
				if maxRelativeFluxes[i] < abs(dNidt[i])/charFlux:
					maxRelativeFluxes[i] = abs(dNidt[i])/charFlux
				
			# Test for model validity
			criticalFlux = charFlux * model.fluxTolerance_interruptSimulation
			valid, maxSpecies, maxSpeciesFlux = self.isModelValid(model, dNidt, criticalFlux)
			
			# invalid if core empty
			if len(model.core.reactions)==0: 
				logging.info("No reactions in core yet. Not running simulation.")
				valid=False
			
			# Output information about simulation at current time
			self.printSimulationStatus(model, time, solver.y, y0, criticalFlux, maxSpeciesFlux, maxSpecies)
			tlist.append(time); ylist.append(solver.y)
			#dydtlist.append(self.getResidual(time, solver.y, model, stoichiometry))
			
			# Exit simulation if model is not valid (exceeds interruption criterion)
			if not valid:
				logging.info('At t = %s, an edge species flux exceeds the critical flux for simulation interruption' % (time))
				logging.info('\tCharacteristic flux: %s' % (charFlux))
				logging.info('\tCritical flux: %s (%s times charFlux)' % (criticalFlux, model.fluxTolerance_interruptSimulation))
				logging.info('\tSpecies flux for %s: %s (%.2g times charFlux)' % (maxSpecies, maxSpeciesFlux, maxSpeciesFlux/charFlux))
				logging.info('')
				#for i in range(len(dNidt)):
				#	if i < len(model.core.species):
				#		print model.core.species[i], maxSpeciesFluxes[i]
				#	else:
				#		print model.edge.species[i-len(model.core.species)], maxSpeciesFluxes[i]
				print gas
				return tlist, ylist, dydtlist, False, maxSpecies
			
			# Test for simulation completion
			for target in model.termination:
				if target.__class__ == TerminationConversion:
					index = model.core.species.index(target.species) + 3
					conversion = 1.0 - solver.y[index] / y0[index]
					if conversion > target.conversion: done = True
				elif target.__class__ == TerminationTime:
					if time > target.time: done = True
		
		print gas 
		
		# Test for model validity once simulation complete
		maxSpecies = None
		maxRelativeFlux = 0.0
		speciesToRemove = []
		for i in range(len(model.core.species), len(maxRelativeFluxes)):
			# pick out the single highest-flux edge species
			if maxRelativeFluxes[i] > maxRelativeFlux:
				maxRelativeFlux = maxRelativeFluxes[i]
				maxSpecies = model.edge.species[i - len(model.core.species)]
				# mark for removal those species whose flux is always too low
				if maxRelativeFluxes[i] < model.fluxTolerance_keepInEdge:
					speciesToRemove.append(model.edge.species[i - len(model.core.species)])
		
		# trim the edge
		logging.info("Removing from edge %d/%d species whose relative flux never exceeded %s"%( 
			len(speciesToRemove),len(model.edge.species),model.fluxTolerance_keepInEdge))
		for sp in speciesToRemove:	
			logging.info("Removing %s"%(sp))
			model.removeSpeciesFromEdge(sp)
		
		if maxRelativeFlux > model.fluxTolerance_moveToCore:
			logging.info('At some time the species flux for %s exceeded the critical flux\nrelative to the characteristic core flux at that time' % (maxSpecies))
			logging.info('\tCritical Relative flux: %s' % (model.fluxTolerance_moveToCore))
			logging.info('\tHighest Relative flux for %s: %s ' % (maxSpecies, maxRelativeFlux))
			logging.info('')
			
			return tlist, ylist, dydtlist, False, maxSpecies
			
		#for i in range(len(model.core.species), len(dNidt)):
			#		if i < len(model.core.species):
			#			print model.core.species[i], maxSpeciesFluxes[i]
			#		else:
			#			print model.edge.species[i-len(model.core.species)], maxSpeciesFluxes[i]
		
		return tlist, ylist, dydtlist, True, None

	def printSimulationStatus(self, model, t, y, y0, charFlux, maxSpeciesFlux, maxSpecies):
		"""
		Log a line of text describing the current status of the simulation. The
		information logged is the current time `t`, the current conversion of
		all species being monitored for conversion targets, the characteristic
		flux `charFlux`, the maximum species flux `maxSpeciesFlux`, and the
		species with that flux `maxSpecies`.
		"""
		
		# Output information about simulation at current time
		status = '%8.4e' % (t)
		for target in model.termination:
			if target.__class__ == TerminationConversion:
				index = model.core.species.index(target.species) + 3
				conversion = 1.0 - y[index] / y0[index]
				status += '    %8.4g' % (conversion)
		status += '    %8.4e    %8.4e  %s' % (charFlux, maxSpeciesFlux, maxSpecies)
		logging.debug(status)
		
		#print t, P, V, T, Ni

	def postprocess(self, model, t, y, dydt, label=''):
		"""
		Postprocess the results of a simulation. This function generates a
		number of plots: temperature, pressure, volume, and concentration
		profiles. The parameters are the reaction `model`, the list of times
		`t`, the list of state vectors `y`, and an optional `label` for the
		reaction system.
		"""
		# Only do if the option for plot generation has been set
		if not settings.generatePlots:
			return
		import pylab
		# Reshape y into a matrix rather than a list of lists
		y0 = numpy.zeros((len(t), len(y[0])), float)
		for i, u in enumerate(y):
			for j, v in enumerate(u):
				y0[i,j] = v
		## Reshape dydt into a matrix rather than a list of lists
		#dydt0 = numpy.zeros((len(t), len(dydt[0])), float)
		#for i, u in enumerate(dydt):
		#	for j, v in enumerate(u):
		#		dydt0[i,j] = v

		# Create the legend for the concentration profile
		legend = []
		for spec in model.core.species:
			legend.append(str(spec))

		# Make pressure plot and save to file
		pylab.semilogx(t[1:], y0[1:,0])
		pylab.xlabel('Time (s)')
		pylab.ylabel('Pressure (Pa)')
		pylab.title('Pressure profile for reaction system ' + label)
		pylab.savefig(settings.outputDirectory + '/plot/pressureProfile' + label + '.svg')
		pylab.clf()

		# Make volume plot and save to file
		pylab.semilogx(t[1:], y0[1:,1])
		pylab.xlabel('Time (s)')
		pylab.ylabel('Volume (m^3)')
		pylab.title('Volume profile for reaction system ' + label)
		pylab.savefig(settings.outputDirectory + '/plot/volumeProfile' + label + '.svg')
		pylab.clf()

		# Make temperature plot and save to file
		pylab.semilogx(t[1:], y0[1:,2])
		pylab.xlabel('Time (s)')
		pylab.ylabel('Temperature (K)')
		pylab.title('Temperature profile for reaction system ' + label)
		pylab.savefig(settings.outputDirectory + '/plot/temperatureProfile' + label + '.svg')
		pylab.clf()

		# Make concentration plot and save to file
		pylab.loglog(t[1:], y0[1:,3:])
		pylab.xlabel('Time (s)')
		pylab.ylabel('Concentration (mol/m^3)')
		pylab.title('Concentration profiles for reaction system ' + label)
		pylab.legend(legend)
		pylab.savefig(settings.outputDirectory + '/plot/concentrationProfile' + label + '.svg')
		pylab.clf()

		## Make species flux plot and save to file
		#try:
		#	pylab.loglog(t[1:], abs(dydt0[1:,3:len(model.core.species)+3]))
		#	pylab.xlabel('Time (s)')
		#	pylab.ylabel('Species flux (mol/m^3*s)')
		#	pylab.title('Species flux profiles for reaction system ' + label)
		#	pylab.legend(legend)
		#	pylab.savefig(settings.outputDirectory + '/plot/fluxProfile' + label + '.svg')
		#except OverflowError:
		#	pass
		
		pylab.clf()
	
################################################################################

class TerminationTime:
	"""
	Represent a time at which the simulation should be terminated. This class
	has one attribute: the termination `time` in seconds.
	"""

	def __init__(self, time=0.0):
		self.time = time

################################################################################

class TerminationConversion:
	"""
	Represent a conversion at which the simulation should be terminated. This
	class has two attributes: the `species` to monitor and the fractional
	`conversion` at which to terminate.
	"""

	def __init__(self, spec=None, conv=0.0):
		self.species = spec
		self.conversion = conv

################################################################################

if __name__ == '__main__':

	import chem
	import data
	import species
	import reaction
	import thermo
	
	import os.path
	import main
	main.initializeLog(logging.DEBUG)

	datapath = '../data/RMG_database/'

	logging.debug('General database: ' + os.path.abspath(datapath))
	species.thermoDatabase = species.ThermoDatabaseSet()
	species.thermoDatabase.load(datapath)
	thermo.forbiddenStructures = data.Dictionary()
	thermo.forbiddenStructures.load(datapath + 'forbiddenStructure.txt')
	thermo.forbiddenStructures.toStructure()
	#reaction.kineticsDatabase = reaction.ReactionFamilySet()
	#reaction.kineticsDatabase.load(datapath)

	structure = chem.Structure(); structure.fromSMILES('C')
	CH4 = species.makeNewSpecies(structure)

	structure = chem.Structure(); structure.fromSMILES('[H]')
	H = species.makeNewSpecies(structure)

	structure = chem.Structure(); structure.fromSMILES('[CH3]')
	CH3 = species.makeNewSpecies(structure)

	forward = reaction.Reaction([CH3, H], [CH4])
	reverse = reaction.Reaction([CH4], [CH3, H])
	forward.reverse = reverse
	reverse.reverse = forward

	kinetics = reaction.ArrheniusEPKinetics()
	kinetics.fromDatabase([300, 2000, 1.93E14, 0, 0, 0.27, 0, 0, 0, 0, 3], '', 2)
	forward.kinetics = [kinetics]

	speciesList = [CH3, H, CH4]
	reactionList = [forward]

	reactionSystem = BatchReactor()
	reactionSystem.temperatureModel = TemperatureModel()
	reactionSystem.temperatureModel.setIsothermal(pq.Quantity(1000, 'K'))
	reactionSystem.pressureModel = PressureModel()
	reactionSystem.pressureModel.setIsobaric(pq.Quantity(1, 'bar'))
	reactionSystem.equationOfState = IdealGas()
	reactionSystem.initialConcentration[CH4] = pq.Quantity(1, 'mol/m**3')

	reactionSystem.solve(0.0, 1.0e0, speciesList, reactionList)
	
	