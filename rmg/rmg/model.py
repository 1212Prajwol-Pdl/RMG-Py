#!/usr/bin/python
# -*- coding: utf-8 -*-

################################################################################
#
#	RMG - Reaction Mechanism Generator
#
#	Copyright (c) 2002-2009 Prof. William H. Green (whgreen@mit.edu) and the
#	RMG Team (rmg_dev@mit.edu)
#
#	Permission is hereby granted, free of charge, to any person obtaining a
#	copy of this software and associated documentation files (the 'Software'),
#	to deal in the Software without restriction, including without limitation
#	the rights to use, copy, modify, merge, publish, distribute, sublicense,
#	and/or sell copies of the Software, and to permit persons to whom the
#	Software is furnished to do so, subject to the following conditions:
#
#	The above copyright notice and this permission notice shall be included in
#	all copies or substantial portions of the Software.
#
#	THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#	DEALINGS IN THE SOFTWARE.
#
################################################################################

"""
Contains classes for working with the reaction model generated by RMG.
"""

import logging
import math
import numpy
import os
import os.path

import chempy.constants as constants
import chempy.species
import chempy.reaction
from chempy.thermo import WilhoitModel, NASAModel
from chempy.kinetics import ArrheniusModel, ChebyshevModel, PDepArrheniusModel

from rmgdata.thermo import generateThermoData, convertThermoData
from rmgdata.kinetics import generateKineticsData
from rmgdata.states import generateFrequencyData

import measure.network

import settings
import ctml_writer
from rxngen import generateReactions

################################################################################

class Species(chempy.species.Species):

    def generateThermoData(self, thermoClass=NASAModel):
        """
        Generate thermodynamic data for the species using the thermo database.

        Generates the thermo data for each structure (resonance isomer),
        picks that with lowest H298 value, and saves it to `self.thermoData`.
        """

        # Ensure molecules are using explicit hydrogens
        implicitH = [mol.implicitHydrogens for mol in self.molecule]
        for molecule in self.molecule:
            molecule.makeHydrogensExplicit()
        
        thermo = []
        for molecule in self.molecule:
            molecule.clearLabeledAtoms()
            molecule.updateAtomTypes()
            tdata = generateThermoData(molecule)
            thermo.append(tdata)

        H298 = numpy.array([t.getEnthalpy(298.) for t in thermo])
        indices = H298.argsort()

        # If multiple resonance isomers are present, use the thermo data of
        # the most stable isomer (i.e. one with lowest enthalpy of formation)
        # as the thermo data of the species
        self.thermo = thermo[indices[0]]

        # Sort the structures in order of decreasing stability
        self.molecule = [self.molecule[ind] for ind in indices]
        implicitH = [implicitH[ind] for ind in indices]

        # Convert to desired thermo class
        thermo0 = self.thermo
        self.thermo = convertThermoData(self.thermo, self.molecule[0], WilhoitModel)
        self.E0 = self.thermo.getEnthalpy(1.0)
        self.thermo = convertThermoData(self.thermo, self.molecule[0], thermoClass)
        if self.thermo.__class__ != thermo0.__class__:
            # Compute RMS error of overall transformation
            Tlist = numpy.array([300.0, 400.0, 500.0, 600.0, 800.0, 1000.0, 1500.0], numpy.float64)
            err = math.sqrt(numpy.sum((self.thermo.getHeatCapacities(Tlist) - thermo0.getHeatCapacities(Tlist))**2))/constants.R/len(Tlist)
            logging.log(logging.WARNING if err > 0.1 else 0, 'Average RMS error in heat capacity fit to %s = %g*R' % (self, err))

        # Restore implicit hydrogens if necessary
        for implicit, molecule in zip(implicitH, self.molecule):
            if implicit: molecule.makeHydrogensImplicit()

        return self.thermo

    def generateStatesData(self):
        """
        Generate molecular degree of freedom data for the species. You must
        have already provided a thermodynamics model using e.g.
        :meth:`generateThermoData()`.
        """
        if not self.thermo:
            raise Exception("Unable to determine states model for species %s: No thermodynamics model found." % self)
        molecule = self.molecule[0]
        implicitH = molecule.implicitHydrogens
        molecule.makeHydrogensExplicit()
        self.states = generateFrequencyData(molecule, self.thermo)
        if implicitH: molecule.makeHydrogensImplicit()

    def generateLennardJonesParameters(self):
        """
        Generate the Lennard-Jones parameters for the species. This "algorithm"
        is *very* much in need of improvement.
        """

        count = sum([1 for atom in self.molecule[0].vertices if atom.isNonHydrogen()])
        self.lennardJones = chempy.species.LennardJones()

        if count == 1:
            self.lennardJones.sigma = 3.758e-10
            self.lennardJones.epsilon = 148.6 * constants.kB
        elif count == 2:
            self.lennardJones.sigma = 4.443e-10
            self.lennardJones.epsilon = 110.7 * constants.kB
        elif count == 3:
            self.lennardJones.sigma = 5.118e-10
            self.lennardJones.epsilon = 237.1 * constants.kB
        elif count == 4:
            self.lennardJones.sigma = 4.687e-10
            self.lennardJones.epsilon = 531.4 * constants.kB
        elif count == 5:
            self.lennardJones.sigma = 5.784e-10
            self.lennardJones.epsilon = 341.1 * constants.kB
        else:
            self.lennardJones.sigma = 5.949e-10
            self.lennardJones.epsilon = 399.3 * constants.kB

    def toCantera(self):
        """
        Return a Cantera ctml_writer instance.
        """
        import ctml_writer
        import xml.sax.saxutils
        # contrivedly get a list like ['C', '3', 'H', '9', 'Si', '1']
        atoms = self.molecule[0].toOBMol().GetSpacedFormula().split()
        # magically turn that lst into a string like 'C:3 H:9 Si:1'
        atoms = ' '.join([i+':'+j for i,j in zip(*[iter(atoms)]*2)])
        thermo = None; note = ''
        if self.reactive:
            thermo = self.thermo.toCantera()
            # this escaping should really be done by ctml_writer, but it doesn't do it
            note = xml.sax.saxutils.escape("%s (%s)"%(self.label,self.thermo.comment))
        return ctml_writer.species(name = str(self),
            atoms = " %s "%atoms,
            thermo = thermo,
            note = note
               )

################################################################################

class Reaction(chempy.reaction.Reaction):

    def __init__(self, index=-1, reactants=None, products=None, kinetics=None, reversible=True, transitionState=None, thirdBody=False, family=None, isForward=True):
        chempy.reaction.Reaction.__init__(self, index, reactants, products, kinetics, reversible, transitionState, thirdBody)
        self.family = family
        self.isForward = isForward
        self.multiplier = 1.0

    def isIsomerization(self):
        """
        Return ``True`` if the reaction represents an isomerization reaction
        :math:`\\ce{A <=> B}` or ``False`` if not.
        """
        return len(self.reactants) == 1 and len(self.products) == 1

    def isAssociation(self):
        """
        Return ``True`` if the reaction represents an association reaction
        :math:`\\ce{A + B <=> C}` or ``False`` if not.
        """
        return len(self.reactants) > 1 and len(self.products) == 1

    def isDissociation(self):
        """
        Return ``True`` if the reaction represents a dissociation reaction
        :math:`\\ce{A <=> B + C}` or ``False`` if not.
        """
        return len(self.reactants) == 1 and len(self.products) > 1

    def generateKineticsData(self):
        """
        Generate kinetcs data for the reaction using the kinetics database.
        """
        self.kinetics = generateKineticsData(self, self.family.label, self.reactantMolecules)
        if not isinstance(self.kinetics, ArrheniusModel):
            self.kinetics = self.kinetics.toArrhenius(self.getEnthalpyOfReaction(298.15))

    def toCantera(self):
        """
        Return a Cantera ctml_writer instance.
        """
        self.canteraReaction = getCanteraReaction(self)

        A = float(self.kinetics.A)
        Ea = float(self.kinetics.Ea)
        n = float(self.kinetics.n)
        self.canteraReaction._kf = ctml_writer.Arrhenius(A, n, Ea)

        return self.canteraReaction

def getCanteraReaction(reaction):
    """
    For a given :class:`Reaction` object `reaction`, create and return a
    Cantera reaction object.
    """

    import ctml_writer

    options = []

    makeCanteraReaction = True
    try:
        if reaction.canteraReaction is not None:
            makeCanteraReaction = False
    except AttributeError:
        pass

    if not makeCanteraReaction:
        # If we're updating this reaction, then remove the original version
        ctml_writer._reactions.remove(reaction.canteraReaction)
        # If the old reaction was a duplicate, then the new one is too
        if 'duplicate' in reaction.canteraReaction._options:
            options.append('duplicate')
    else:
        # If we're making this reaction for the first time then we need to
        # check for duplicate reactions
        # Get ID of each reactant and product of this reaction
        reactants = [str(r) for r in reaction.reactants]; reactants.sort()
        products = [str(p) for p in reaction.products]; products.sort()
        # Remove any IDs that appear in both the reactant and product lists
        # This is because Cantera treats A --> B + C and A + D --> B + C + D
        # as requiring the duplicate tag
        speciesToRemove = []
        for spec in reactants:
            if spec in products: speciesToRemove.append(spec)
        speciesToRemove = list(set(speciesToRemove))
        for spec in speciesToRemove:
            reactants.remove(spec)
            products.remove(spec)
        # Iterate over all existing Cantera reactions
        for rxn in ctml_writer._reactions:
            # Get ID of each reactant and product
            reac = []; prod = []
            for r, v in rxn._r.iteritems():
                for i in range(int(v)): reac.append(r)
            for p, v in rxn._p.iteritems():
                for i in range(int(v)): prod.append(p)
            reac.sort(); prod.sort()
            # Remove any IDs that appear in both the reactant and product lists
            speciesToRemove = []
            for spec in reac:
                if spec in prod: speciesToRemove.append(spec)
            speciesToRemove = list(set(speciesToRemove))
            for spec in speciesToRemove:
                reac.remove(spec)
                prod.remove(spec)
            # Compare with reactants and products of this reaction
            if (reactants == reac and products == prod) or (reactants == prod and products == reac):
                if 'duplicate' not in options or 'duplicate' not in rxn._options:
                    logging.debug('Marking reaction %s as duplicate' % (reaction))
                if 'duplicate' not in options:
                    options.append('duplicate')
                if 'duplicate' not in rxn._options:
                    rxn._options.append('duplicate')

    rxnstring = ' + '.join([str(sp) for sp in reaction.reactants])
    rxnstring += ' <=> '
    rxnstring += ' + '.join([str(sp) for sp in reaction.products])

    return ctml_writer.reaction(rxnstring, options=options)

class PDepReaction(chempy.reaction.Reaction):

    def __init__(self, index=-1, reactants=None, products=None, network=None, kinetics=None, reversible=True, transitionState=None, thirdBody=False):
        chempy.reaction.Reaction.__init__(self, index, reactants, products, kinetics, reversible, transitionState, thirdBody)
        self.network = network

    def toCantera(self):
        """Add this to Cantera ctml_writer"""
        self.canteraReaction = getCanteraReaction(self)

        # replace the forward rate coefficient
        rate_function_of_T_P = self.kinetics.getRateCoefficient
        self.canteraReaction._kf = ctml_writer.PdepRate(rate_function_of_T_P)
        
        return self.canteraReaction

################################################################################

class Network(measure.network.Network):

    def getLeakFlux(self, T, P, conc):
        """
        Return the leak flux of the network: the forward flux to all unexplored
        unimolecular isomers in the network. If there is only one path (and
        therefore net) reaction and its unimolecular reactants and/or products
        have not been explored, then it uses the high-pressure-limit rate to
        ensure it is considering the maximum possible rate.
        """

        self.leakFluxes = {}

        # If only one path/net reaction and it contains an isomer that has not
        # been explored, then use the high-pressure-limit k(T) to calculate
        # the flux rather than the phenomenological k(T,P) value
        if len(self.netReactions) == 1 and len(self.pathReactions) == 1:
            rxn = self.netReactions[0]
            rate = self.pathReactions[0].getRate(T, P, conc)
            if len(rxn.reactants) == 1 and rxn.reactants[0] not in self.explored:
                self.leakFluxes[rxn.reactants[0]] = -rate
            if len(rxn.products) == 1 and rxn.products[0] not in self.explored:
                self.leakFluxes[rxn.products[0]] = rate
        # Otherwise get leak fluxes of all unexplored [unimolecular] isomers
        else:
            for rxn in self.netReactions:
                rate = rxn.getRate(T, P, conc)
                if len(rxn.reactants) == 1 and rxn.reactants[0] not in self.explored:
                    spec = rxn.reactants[0]
                    if spec in self.leakFluxes:
                        self.leakFluxes[spec] -= rate
                    else:
                        self.leakFluxes[spec] = -rate
                if len(rxn.products) == 1 and rxn.products[0] not in self.explored:
                    spec = rxn.products[0]
                    if spec in self.leakFluxes:
                        self.leakFluxes[spec] += rate
                    else:
                        self.leakFluxes[spec] = rate

        return sum([abs(v) for v in self.leakFluxes.values()])

    def getMaximumLeakSpecies(self):
        """
        Get the unexplored (unimolecular) isomer with the maximum leak flux.
        """
        if len(self.leakFluxes) == 0:
            raise UnirxnNetworkException('No unimolecular isomers left to explore!')

        # Choose species with maximum leak flux
        maxSpeciesFlux = 0.0; maxSpecies = None
        for spec, flux in self.leakFluxes.iteritems():
            if maxSpecies is None or flux > maxSpeciesFlux:
                maxSpecies = spec; maxSpeciesFlux = flux

        # Return the species and flux
        return maxSpecies, maxSpeciesFlux

################################################################################

class ReactionModel:
    """
    Represent a generic reaction model. A reaction model consists of `species`,
    a list of species, and `reactions`, a list of reactions.
    """

    def __init__(self, species=None, reactions=None):
        self.species = species or []
        self.reactions = reactions or []

################################################################################

class CoreEdgeReactionModel:
    """
    Represent a reaction model constructed using a rate-based screening
    algorithm. The species and reactions in the model itself are called the
    *core*; the species and reactions identified as candidates for inclusion in
    the model are called the *edge*. The attributes are:

    =========================  ==============================================================
    Attribute                  Description
    =========================  ==============================================================
    `core`                     The species and reactions of the current model core
    `edge`                     The species and reactions of the current model edge
    `absoluteTolerance`        The absolute tolerance used in the ODE/DAE solver
    `relativeTolerance`        The relative tolerance used in the ODE/DAE solver
    `fluxToleranceKeepInEdge`  The relative species flux below which species are discarded from the edge
    `fluxToleranceMoveToCore`  The relative species flux above which species are moved from the edge to the core
    `fluxToleranceInterrupt`   The relative species flux above which the simulation will halt
    `maximumEdgeSpecies`       The maximum number of edge species allowed at any time
    `termination`              A list of termination targets (i.e :class:`TerminationTime` and :class:`TerminationConversion` objects)
    `unirxnNetworks`           A list of unimolecular reaction networks (:class:`unirxn.network.Network` objects)
    `networkCount`             A counter for the number of unirxn networks created
    =========================  ==============================================================


    """

    def __init__(self, core=None, edge=None):
        if core is None:
            self.core = ReactionModel()
        else:
            self.core = core
        if edge is None:
            self.edge = ReactionModel()
        else:
            self.edge = edge
        # The default tolerances mimic the original RMG behavior; no edge
        # pruning takes place, and the simulation is interrupted as soon as
        # a species flux higher than the validity
        self.fluxToleranceKeepInEdge = 0.0
        self.fluxToleranceMoveToCore = 1.0
        self.fluxToleranceInterrupt = 1.0
        self.absoluteTolerance = 1.0e-8
        self.relativeTolerance = 1.0e-4
        self.maximumEdgeSpecies = 1000000
        self.termination = []
        self.unirxnNetworks = []
        self.networkCount = 0
        self.speciesList = []
        self.reactionDict = {'seed': {}}
        self.speciesCache = [None for i in range(4)]
        self.speciesCounter = 0
        self.reactionCounter = 0

    def checkForExistingSpecies(self, molecule):
        """
        Check to see if an existing species contains the same
        :class:`structure.Structure` as `structure`. Returns ``True`` or
        ``False`` and the matched species (if found, or ``None`` if not).
        """

        # First check cache and return if species is found
        for i, spec in enumerate(self.speciesCache):
            if spec is not None:
                for mol in spec.molecule:
                    if molecule.isIsomorphic(mol):
                        self.speciesCache.pop(i)
                        self.speciesCache.insert(0, spec)
                        return True, spec

        # Return an existing species if a match is found
        for spec in self.speciesList:
            for mol in spec.molecule:
                if molecule.isIsomorphic(mol):
                    self.speciesCache.pop()
                    self.speciesCache.insert(0, spec)
                    return True, spec

        # At this point we can conclude that the structure does not exist
        return False, None

    def makeNewSpecies(self, molecule, label='', reactive=True, checkForExisting=True):
        """
        Create a new species.
        """

        molecule.makeHydrogensImplicit()

        # If desired, check to ensure that the species is new; return the
        # existing species if not new
        if checkForExisting:
            found, spec = self.checkForExistingSpecies(molecule)
            if found: return spec, False

        # Check that the structure is not forbidden

        # If we're here then we're ready to make the new species
        if label == '': label = molecule.toSMILES()
        logging.debug('Creating new species %s' % str(label))
        spec = Species(index=len(self.speciesList)+1, label=label, molecule=[molecule], reactive=reactive)
        spec.generateResonanceIsomers()
        spec.molecularWeight = spec.molecule[0].getMolecularWeight()
        spec.generateLennardJonesParameters()
        self.speciesList.append(spec)

        # Store hydrogens implicitly to conserve memory and speed up isomorphism
        for mol in spec.molecule:
            #mol.updateConnectivityValues()
            mol.makeHydrogensImplicit()

        self.speciesCounter += 1

        return spec, True

    def checkForExistingReaction(self, rxn):
        """
        Check to see if an existing reaction has the same reactants, products, and
        family as `rxn`. Returns :data:`True` or :data:`False` and the matched
        reaction (if found).
        """

        # Get the short-list of reactions with the same family, reactant1 and reactant2
        r1 = rxn.reactants[0]
        if len(rxn.reactants)==1: r2 = None
        else: r2 = rxn.reactants[1]
        try:
            my_reactionList = self.reactionDict[rxn.family][r1][r2]
        except KeyError: # no such short-list: must be new, unless in seed.
            my_reactionList = []

        # Now use short-list to check for matches. All should be in same forward direction.
        for rxn0 in my_reactionList:
            if (rxn0.reactants == rxn.reactants and rxn0.products == rxn.products):
                return True, rxn0

        # Now check seed reactions.
        # First check seed short-list in forward direction
        try:
            my_reactionList = self.reactionDict['seed'][r1][r2]
        except KeyError:
            my_reactionList = []
        for rxn0 in my_reactionList:
            if (rxn0.reactants == rxn.reactants and rxn0.products == rxn.products) or \
                (rxn0.reactants == rxn.products and rxn0.products == rxn.reactants):
                return True, rxn0
        # Now get the seed short-list of the reverse reaction
        r1 = rxn.products[0]
        if len(rxn.products)==1: r2 = None
        else: r2 = rxn.products[1]
        try:
            my_reactionList = self.reactionDict['seed'][r1][r2]
        except KeyError:
            my_reactionList = []
        for rxn0 in my_reactionList:
            if (rxn0.reactants == rxn.reactants and rxn0.products == rxn.products) or \
                (rxn0.reactants == rxn.products and rxn0.products == rxn.reactants):
                return True, rxn0

        return False, None

    def makeNewReaction(self, forward, checkExisting=True):
        """
        Make a new reaction given a :class:`Reaction` object `forward`. The kinetics
        of the reaction are estimated and the reaction is added to the global list
        of reactions. Returns the reaction in the direction that corresponds to the
        estimated kinetics, along with whether or not the reaction is new to the
        global reaction list.

        The forward direction is determined using the "is_reverse" attribute of the
        reaction's family.  If the reaction family is its own reverse, then it is
        made such that the forward reaction is exothermic at 298K.
        """

        if checkExisting:
            found, rxn = self.checkForExistingReaction(forward)
            if found: return rxn, False

        # Note in the log
        logging.debug('Creating new %s reaction %s' % (forward.family.label, forward))

        # Add to the global dict/list of existing reactions (a list broken down by family, r1, r2)
        # identify r1 and r2
        r1 = forward.reactants[0]
        r2 = None if len(forward.reactants) == 1 else forward.reactants[1]
        # make dictionary entries if necessary
        if forward.family not in self.reactionDict:
            self.reactionDict[forward.family] = {}
        if not self.reactionDict[forward.family].has_key(r1):
            self.reactionDict[forward.family][r1] = dict()
        if not self.reactionDict[forward.family][r1].has_key(r2):
            self.reactionDict[forward.family][r1][r2] = list()
        # store this reaction at the top of the relevant short-list
        self.reactionDict[forward.family][r1][r2].insert(0, forward)

        forward.index = self.reactionCounter + 1
        self.reactionCounter += 1

        # Return newly created reaction
        return forward, True

    def makeNewPDepReaction(self, forward):
        """
        Make a new pressure-dependent reaction based on a list of `reactants` and a
        list of `products`. The reaction belongs to the specified `network` and
        has pressure-dependent kinetics given by `kinetics`.

        No checking for existing reactions is made here. The returned PDepReaction
        object is not added to the global list of reactions, as that is intended
        to represent only the high-pressure-limit set. The reactionCounter is
        incremented, however, since the returned reaction can and will exist in
        the model edge and/or core.
        """

        # Create reverse reaction
        reverse = PDepReaction(reactants=forward.products, products=forward.reactants, network=forward.network, kinetics=None)
        forward.reverse = reverse
        reverse.reverse = forward

        # Set reaction index and increment the counter
        forward.index = self.reactionCounter + 1
        reverse.index = self.reactionCounter + 1
        self.reactionCounter += 1

        return forward

    def enlarge(self, newObject):
        """
        Enlarge a reaction model by processing `newObject`. If `newObject` is a
        :class:`rmg.species.Species` object, then the species is moved from
        the edge to the core and reactions generated for that species, reacting
        with itself and with all other species in the model core. If `newObject`
        is a :class:`rmg.unirxn.network.Network` object, then reactions are
        generated for the species in the network with the largest leak flux.
        """

        newReactionList = []; newSpeciesList = []

        numOldCoreSpecies = len(self.core.species)
        numOldCoreReactions = len(self.core.reactions)

        if isinstance(newObject, Species):

            newSpecies = newObject

            if not newSpecies.reactive:
                logging.info('NOT generating reactions for unreactive species %s' % newSpecies)
            else:
                # Find reactions involving the new species as unimolecular reactant
                # or product (e.g. A <---> products)
                r, s = generateReactions([newSpecies], self)
                newReactionList.extend(r); newSpeciesList.extend(s)
                # Find reactions involving the new species as bimolecular reactants
                # or products with other core species (e.g. A + B <---> products)
                for coreSpecies in self.core.species:
                    if coreSpecies.reactive:
                        r, s = generateReactions([newSpecies, coreSpecies], self)
                        newReactionList.extend(r); newSpeciesList.extend(s)
                # Find reactions involving the new species as bimolecular reactants
                # or products with itself (e.g. A + A <---> products)
                r, s = generateReactions([newSpecies, newSpecies], self)
                newReactionList.extend(r); newSpeciesList.extend(s)

            # Add new species
            self.addSpeciesToCore(newSpecies)

        elif isinstance(newObject, Network) and settings.pressureDependence:

            network = newObject
            # Determine the species with the maximum leak flux
            maxSpecies, maxSpeciesFlux = network.getMaximumLeakSpecies()
            network.explored.append(maxSpecies)
            # Find reactions involving the found species as unimolecular
            # reactant or product (e.g. A <---> products)
            r, s = generateReactions([maxSpecies], self)
            newReactionList.extend(r); newSpeciesList.extend(s)
            # Don't find reactions involving the new species as bimolecular
            # reactants or products with itself (e.g. A + A <---> products)
            # Don't find reactions involving the new species as bimolecular
            # reactants or products with other core species (e.g. A + B <---> products)

        else:
            raise TypeError('Unable to use object %s to enlarge reaction model; expecting an object of class rmg.species.Species or rmg.unirxn.network.Network.' % newObject)

        # Add new reactions generated in above
        for rxn in newReactionList:
            allSpeciesInCore = True
            for spec in rxn.reactants:
                if spec not in self.core.species:
                    allSpeciesInCore = False
                    if spec not in self.edge.species:
                        self.addSpeciesToEdge(spec)
            for spec in rxn.products:
                if spec not in self.core.species:
                    allSpeciesInCore = False
                    if spec not in self.edge.species:
                        self.addSpeciesToEdge(spec)
            # If pressure dependence is on, we only add reactions that are not unimolecular;
            # unimolecular reactions will be added after processing the associated networks
            if not settings.pressureDependence or not (
                rxn.isIsomerization() or rxn.isDissociation() or rxn.isAssociation()):
                if allSpeciesInCore:
                    self.addReactionToCore(rxn)
                else:
                    self.addReactionToEdge(rxn)
            else:
                # Update unimolecular reaction networks
                net = self.addReactionToUnimolecularNetworks(rxn)
                if net is not None and isinstance(newObject, Species):
                    if (len(rxn.reactants) == 1 and rxn.reactants[0] == newObject) or (len(rxn.products) == 1 and rxn.products[0] == newObject):
                        net.explored.append(newObject)

        # Generate thermodynamics of new species
        logging.info('Generating thermodynamics for new species...')
        for spec in newSpeciesList:
            spec.generateThermoData()
            
        # Generate kinetics of new reactions
        logging.info('Generating kinetics for new reactions...')
        for rxn in newReactionList:
            if rxn.kinetics is None: rxn.generateKineticsData()
            # Now that we have the kinetics we don't need the reactant molecules
            # any more, so delete them to recover the memory
            rxn.reactantMolecules = None
            rxn.reverse.reactantMolecules = None

        # Generate frequencies of new species
        if settings.pressureDependence:
            logging.info('Generating frequencies for new species...')
            for spec in newSpeciesList:
                spec.generateStatesData()

        # Update unimolecular (pressure dependent) reaction networks
        if settings.pressureDependence:
            self.updateUnimolecularReactionNetworks()
            logging.info('')

        # Print summary of enlargement
        if not isinstance(newObject, Species): newSpecies = None
        self.printEnlargeSummary(
            newCoreSpecies=self.core.species[numOldCoreSpecies:],
            newCoreReactions=self.core.reactions[numOldCoreReactions:],
            newEdgeSpecies=newSpeciesList,
            newEdgeReactions=newReactionList,
            newSpecies=newSpecies,
        )

        # Tell Cantera about new core species and core reactions
        for spec in self.core.species[numOldCoreSpecies:]:
            spec.toCantera()
        for rxn in self.core.reactions[numOldCoreReactions:]:
            rxn.toCantera()

        logging.info('')

    def printEnlargeSummary(self, newCoreSpecies, newCoreReactions, newEdgeSpecies, newEdgeReactions, newSpecies=None):
        """
        Output a summary of a model enlargement step to the log. The details of
        the enlargement are passed in the `newCoreSpecies`, `newCoreReactions`,
        `newEdgeSpecies`, and `newEdgeReactions` objects. If the model
        enlargement is based around one species, you may optionally pass that
        species as `newSpecies`, which will cause all of the reactions to be
        printed with that species as the reactant. If `newSpecies` is ``None``,
        the reactions are printed in the direction for which kinetics are known.
        """

        logging.info('')
        logging.info('Summary of Model Enlargement')
        logging.info('----------------------------')
        logging.info('Added %i new core species' % (len(newCoreSpecies)))
        for spec in newCoreSpecies:
            logging.info('    %s' % (spec))
        logging.info('Created %i new edge species' % len(newEdgeSpecies))
        for spec in newEdgeSpecies:
            logging.info('    %s' % (spec))
        logging.info('Added %i new core reactions' % (len(newCoreReactions)))
        for rxn in newCoreReactions:
            logging.info('    %s' % (rxn.reverse if newSpecies in rxn.products else rxn))
        logging.info('Created %i new edge reactions' % len(newEdgeReactions))
        for rxn in newEdgeReactions:
            logging.info('    %s' % (rxn.reverse if newSpecies in rxn.products else rxn))

        # Output current model size information after enlargement
        logging.info('')
        logging.info('After model enlargement:')
        logging.info('    The model core has %s species and %s reactions' % (len(self.core.species), len(self.core.reactions)))
        logging.info('    The model edge has %s species and %s reactions' % (len(self.edge.species), len(self.edge.reactions)))
        logging.info('')

    def addSpeciesToCore(self, spec):
        """
        Add a species `spec` to the reaction model core (and remove from edge if
        necessary). This function also moves any reactions in the edge that gain
        core status as a result of this change in status to the core.
        """

        if spec in self.core.species: return

        # Add the species to the core
        self.core.species.append(spec)

        if spec in self.edge.species:

            # If species was in edge, remove it
            self.edge.species.remove(spec)

            # Search edge for reactions that now contain only core species;
            # these belong in the model core and will be moved there
            rxnList = []
            for rxn in self.edge.reactions:
                allCore = True
                for reactant in rxn.reactants:
                    if reactant not in self.core.species: allCore = False
                for product in rxn.products:
                    if product not in self.core.species: allCore = False
                if allCore: rxnList.append(rxn)

            # Move any identified reactions to the core
            for rxn in rxnList:
                self.addReactionToCore(rxn)

    def addSpeciesToEdge(self, spec):
        """
        Add a species `spec` to the reaction model edge.
        """
        self.edge.species.append(spec)

    def removeSpeciesFromEdge(self, spec):
        """
        Remove species `spec` from the reaction model edge.
        """
        # remove the species
        self.edge.species.remove(spec)
        # identify any reactions it's involved in
        rxnList = []
        for rxn in self.edge.reactions:
            if spec in rxn.reactants or spec in rxn.products:
                rxnList.append(rxn)
        # remove those reactions
        for rxn in rxnList:
            self.edge.reactions.remove(rxn)
            # also remove it from the global list of reactions
            # the PDepReactions on the edge aren't in the global list, so we
            # should not try to remove them
            if not isinstance(rxn, reaction.PDepReaction):
                reaction.removeFromGlobalList(rxn)

        # Remove the species from any unirxn networks it is in
        if settings.pressureDependence:
            networksToDelete = []
            for network in self.unirxnNetworks:
                if spec in network.getSpeciesList():
                    # Delete all path reactions involving the species
                    rxnList = []
                    for rxn in network.pathReactions:
                        if spec in rxn.reactants or spec in rxn.products:
                            rxnList.append(rxn)
                    for rxn in rxnList:
                        network.pathReactions.remove(rxn)
                        reaction.removeFromGlobalList(rxn)
                    # Delete all net reactions involving the species
                    rxnList = []
                    for rxn in network.netReactions:
                        if spec in rxn.reactants or spec in rxn.products:
                            rxnList.append(rxn)
                    for rxn in rxnList:
                        network.netReactions.remove(rxn)
                        # net reactions are not in global reaction list
                        # so don't reaction.removeFromGlobalList(rxn)

                    # Delete all isomers involving the species
                    isomerList = []
                    for isomer in network.isomers:
                        if spec in isomer.species:
                            isomerList.append(isomer)
                    for isomer in isomerList:
                        network.isomers.remove(isomer)
                    # If no remaining reactions, delete the network (actually
                    # add to list of networks to be deleted in a subsequent
                    # step)
                    if len(network.pathReactions) == 0 and len(network.netReactions) == 0:
                        networksToDelete.append(network)

            # Complete deletion of empty networks
            for network in networksToDelete:
                logging.debug('Deleting empty unirxn network %s' % network.index)
                self.unirxnNetworks.remove(network)

        # remove from the global list of species, to free memory
        species.speciesList.remove(spec)

    def addReactionToCore(self, rxn):
        """
        Add a reaction `rxn` to the reaction model core (and remove from edge if
        necessary). This function assumes `rxn` has already been checked to
        ensure it is supposed to be a core reaction (i.e. all of its reactants
        AND all of its products are in the list of core species).
        """
        self.core.reactions.append(rxn)
        if rxn in self.edge.reactions:
            self.edge.reactions.remove(rxn)
        
    def addReactionToEdge(self, rxn):
        """
        Add a reaction `rxn` to the reaction model edge. This function assumes
        `rxn` has already been checked to ensure it is supposed to be an edge
        reaction (i.e. all of its reactants OR all of its products are in the
        list of core species, and the others are in either the core or the
        edge).
        """
        self.edge.reactions.append(rxn)

    def getLists(self):
        """
        Return lists of all of the species and reactions in the core and the
        edge.
        """
        speciesList = []
        speciesList.extend(self.core.species)
        speciesList.extend(self.edge.species)
        reactionList = []
        reactionList.extend(self.core.reactions)
        reactionList.extend(self.edge.reactions)
        return speciesList, reactionList

    def getStoichiometryMatrix(self):
        """
        Return the stoichiometry matrix for all generated species and reactions.
        The id of each species and reaction is the corresponding row and column,
        respectively, in the matrix.
        """
        speciesList, reactionList = self.getLists()
        from scipy import sparse
        stoichiometry = sparse.dok_matrix((self.speciesCounter, self.reactionCounter), float)
        for rxn in reactionList:
            j = rxn.index - 1
            specList = rxn.reactants[:]; specList.extend(rxn.products)
            for spec in specList:
                i = spec.index - 1
                nu = rxn.getStoichiometricCoefficient(spec)
                if nu != 0: stoichiometry[i,j] = nu
        return stoichiometry.tocsr()

    def getReactionRates(self, T, P, Ci):
        """
        Return an array of reaction rates for each reaction in the model core
        and edge. The id of the reaction is the index into the vector.
        """
        speciesList, reactionList = self.getLists()
        rxnRate = numpy.zeros(self.reactionCounter, float)
        for rxn in reactionList:
            j = rxn.index - 1
            rxnRate[j] = rxn.getRate(T, P, Ci)
        return rxnRate

    def addSeedMechanismToCore(self, seedMechanism, react=False):
        """
        Add all species and reactions from `seedMechanism`, a 
        :class:`KineticsPrimaryDatabase` object, to the model core. If `react`
        is ``True``, then reactions will also be generated between the seed
        species. For large seed mechanisms this can be prohibitively expensive,
        so it is not done by default.
        """
        
        rxnList = []; speciesList = []

        numOldCoreSpecies = len(self.core.species)
        numOldCoreReactions = len(self.core.reactions)

        logging.info('Adding seed mechanism %s to model core...' % seedMechanism)

        dictionary = seedMechanism.database.dictionary

        for rxn in seedMechanism.reactions:
            forward = Reaction(reactants=rxn.reactants[:], products=rxn.products[:], family=seedMechanism, kinetics=rxn.kinetics, isForward=True)
            for i, reactant in enumerate(forward.reactants):
                label = dictionary.keys()[dictionary.values().index(reactant)]
                forward.reactants[i], isNew = self.makeNewSpecies(reactant, label=label)
                if isNew: speciesList.append(forward.reactants[i])
            for i, product in enumerate(forward.products):
                label = dictionary.keys()[dictionary.values().index(product)]
                forward.products[i], isNew = self.makeNewSpecies(product, label=label)
                if isNew: speciesList.append(forward.products[i])
            # Sort reactants and products
            rxn.reactants.sort()
            rxn.products.sort()

            reverse = Reaction(reactants=rxn.products, products=rxn.reactants, family=seedMechanism, isForward=False)
            forward.reverse = reverse
            reverse.reverse = forward

            r, isNew = self.makeNewReaction(forward)
            if isNew: rxnList.append(r)

        for spec in speciesList:
            if spec.reactive: spec.generateThermoData()
            if react:
                self.enlarge(spec)
            else:
                self.addSpeciesToCore(spec)
            spec.toCantera()

        for rxn in rxnList:
            self.addReactionToCore(rxn)
            rxn.toCantera()

        self.printEnlargeSummary(
            newCoreSpecies=self.core.species[numOldCoreSpecies:],
            newCoreReactions=self.core.reactions[numOldCoreReactions:],
            newEdgeSpecies=[],
            newEdgeReactions=[],
        )

    def addReactionToUnimolecularNetworks(self, newReaction):
        """
        Given a newly-created :class:`Reaction` object `newReaction`, update the
        corresponding unimolecular reaction network. If no network exists, a new
        one is created. If the new reaction is an isomerization that connects two
        existing networks, the two networks are merged. This function is called
        whenever a new high-pressure limit edge reaction is created. Returns the
        network containing the new reaction.
        """

        def getNetworkContainingSpecies(spec, networks):
            for network in networks:
                if network.containsSpecies(spec): return network
            return None

        # If the reaction is not unimolecular, then there's nothing to do
        # Return None because we haven't added newReaction to a network
        if not newReaction.isIsomerization() and not newReaction.isDissociation() and not newReaction.isAssociation():
            return None

        # Find networks containing either the reactant or the product as a
        # unimolecular isomer
        reactantNetwork = None; productNetwork = None
        if newReaction.isIsomerization() or newReaction.isDissociation():
            reactantNetwork = getNetworkContainingSpecies(newReaction.reactants[0], self.unirxnNetworks)
        if newReaction.isIsomerization() or newReaction.isAssociation():
            productNetwork = getNetworkContainingSpecies(newReaction.products[0], self.unirxnNetworks)

        # Action depends on results of above search
        network = None
        if reactantNetwork is not None and productNetwork is not None and reactantNetwork is productNetwork:
            # Found the same network twice, so we don't need to merge
            # This can happend when a net reaction is later generated by RMG as a
            # path reaction
            network = reactantNetwork
        elif reactantNetwork is not None and productNetwork is not None:
            # Found two different networks, so we need to merge
            network = reactantNetwork
            network.merge(productNetwork)
            self.unirxnNetworks.remove(productNetwork)
        elif reactantNetwork is not None and productNetwork is None:
            # Found one network, so we add to it
            network = reactantNetwork
        elif reactantNetwork is None and productNetwork is not None:
            # Found one network, so we add to it
            network = productNetwork
        else:
            # Didn't find any networks, so we need to make a new one
            self.networkCount += 1
            network = Network(index=self.networkCount)
            self.unirxnNetworks.append(network)

        # Add the new reaction to whatever network was found/created above
        network.pathReactions.append(newReaction)
        network.invalidate()
        
        # Return the network that the reaction was added to
        return network

    def updateUnimolecularReactionNetworks(self):
        """
        Iterate through all of the currently-existing unimolecular reaction
        networks, updating those that have been marked as invalid. In each update,
        the phenomonological rate coefficients :math:`k(T,P)` are computed for
        each net reaction in the network, and the resulting reactions added or
        updated.
        """

        from measure.collision import SingleExponentialDownModel
        from measure.reaction import fitInterpolationModel
        import measure.settings
        import measure.output
        
        count = sum([1 for network in self.unirxnNetworks if not network.valid and len(network.explored) > 0])
        logging.info('Updating %i modified unimolecular reaction networks...' % count)

        # For the purposes of RMG we want each network to run very quickly
        # One way to do this is to only calculate the density of states for
        # the unimolecular isomers
        measure.settings.minimizeDensityOfStatesCalculations = True

        # Iterate over all the networks, updating the invalid ones as necessary
        for network in self.unirxnNetworks:
            if not network.valid:

                if len(network.explored) == 0:
                    network.valid = True
                    continue

                # Other inputs
                method, Tmin, Tmax, Tlist, Pmin, Pmax, Plist, grainSize, numGrains, model = settings.pressureDependence

                # Figure out which configurations are isomers, reactant channels, and product channels
                network.isomers = []
                network.reactants = []
                network.products = []
                for rxn in network.pathReactions:
                    # Sort bimolecular configurations so that we always encounter them in the
                    # same order
                    # The actual order doesn't matter, as long as it is consistent
                    rxn.reactants.sort()
                    rxn.products.sort()
                    # Reactants:
                    # - All unimolecular configurations are automatically isomers
                    # - All bimolecular configurations are automatically reactant channels
                    if len(rxn.reactants) == 1 and rxn.reactants[0] not in network.isomers:
                        network.isomers.append(rxn.reactants[0])
                    elif len(rxn.reactants) > 1 and rxn.reactants not in network.isomers:
                        network.reactants.append(rxn.reactants)
                    # Products:
                    # - If reversible, the same actions are taken as for the reactants
                    # - If irreversible, configurations are treated as products
                    if rxn.reversible:
                        if len(rxn.products) == 1 and rxn.products[0] not in network.isomers:
                            network.isomers.append(rxn.products[0])
                        elif len(rxn.products) > 1 and rxn.products not in network.isomers:
                            network.reactants.append(rxn.products)
                    elif rxn.products not in network.products:
                        network.products.append(rxn.products)
                network.isomers.sort(cmp=lambda x, y: x.index - y.index)
                
                # Update list of explored isomers to include all species in core
                for isom in network.isomers:
                    if isom not in network.explored and isom in self.core.species:
                        network.explored.append(isom)

                # Place all unexplored unimolecular isomers as product channels
                isomersToMove = []
                for isomer in network.isomers:
                    if isomer not in network.explored:
                        isomersToMove.append(isomer)
                for isomer in isomersToMove[::-1]:
                    network.isomers.remove(isomer)
                    network.products.insert(0, [isomer])
                
                # Determine transition state energies on potential energy surface
                # In the absence of any better information, we simply set it to
                # be the reactant ground-state energy + the activation energy
                for rxn in network.pathReactions:
                    rxn.transitionState = chempy.species.TransitionState(
                        E0=sum([spec.E0 for spec in rxn.reactants]) + rxn.kinetics.Ea,
                    )

                # Set collision model
                bathGas = [spec for spec in self.core.species if not spec.reactive]
                network.bathGas = {}
                for spec in bathGas:
                    network.bathGas[spec] = 1.0 / len(bathGas)
                network.collisionModel = SingleExponentialDownModel(alpha0=4.86 * 4184)
                
                # Save input file
                measure.output.writeInput(os.path.join(settings.outputDirectory, 'pdep', 'network%i_%i.py' % (network.index, len(network.isomers))),
                    network, Tlist, Plist, (grainSize, numGrains), method, model)

                # Automatically choose a suitable set of energy grains if they were not
                # explicitly specified in the input file
                Elist = network.autoGenerateEnergyGrains(Tmax=Tmax, grainSize=grainSize, Ngrains=numGrains)

                network.printSummary(level=logging.INFO)

                # Calculate the rate coefficients
                K, p0 = network.calculateRateCoefficients(Tlist, Plist, Elist, method)

                # Generate PDepReaction objects
                configurations = []
                configurations.extend([[isom] for isom in network.isomers])
                configurations.extend([reactants for reactants in network.reactants])
                configurations.extend([products for products in network.products])
                for i in range(K.shape[2]):
                    for j in range(i):
                        
                            # Check that we have nonzero k(T,P) values
                            if numpy.any(K[:,:,i,j]):
                                if not numpy.all(K[:,:,i,j]):
                                    raise NetworkError('Zero rate coefficient encountered while updating network %s.' % network)

                                # Find the path reaction
                                netReaction = None
                                for r in network.netReactions:
                                    if r.hasTemplate(configurations[j], configurations[i]):
                                        netReaction = r
                                # If net reaction does not already exist, make a new one
                                if netReaction is None:
                                    netReaction = PDepReaction(
                                        reactants=configurations[j],
                                        products=configurations[i],
                                        network=network,
                                        kinetics=None
                                    )
                                    netReaction = self.makeNewPDepReaction(netReaction)
                                    network.netReactions.append(netReaction)

                                    # Place the net reaction in the core or edge if necessary
                                    # Note that leak reactions are not placed in the edge
                                    if netReaction.reactants in network.reactants or netReaction.reactants in network.products:
                                        pass
                                    elif all([s in self.core.species for s in netReaction.reactants]) and all([s in self.core.species for s in netReaction.products]):
                                        self.addReactionToCore(netReaction)
                                    else:
                                        self.addReactionToEdge(netReaction)

                                # Set/update the net reaction kinetics using interpolation model
                                netReaction.kinetics = fitInterpolationModel(netReaction, Tlist, Plist, K[:,:,i,j], model, Tmin, Tmax, Pmin, Pmax)

                                # Update cantera if this is a core reaction
                                if netReaction in self.core.reactions:
                                    netReaction.toCantera()

                # We're done processing this network, so mark it as valid
                network.valid = True

    def loadSeedMechanism(self, path):
        """
        Loads a seed mechanism from the folder indicated by `path` into the
        core-edge reaction model.
        """

        import os.path
        import quantities as pq
        import data
        import thermo.data
        import kinetics.data
        import reaction

        # Load the species data from the file species.txt
        # This file has the format of a standard RMG dictionary
        d = data.Dictionary()
        d.load(os.path.join(path, 'species.txt'))
        d.toStructure(addH=True)

        # Load the thermo data from the file thermo.txt
        # This file has the format of a standard RMG thermo library
        thermoData = thermo.data.ThermoDatabase()
        thermoData.load(os.path.join(path, 'species.txt'), '', os.path.join(path, 'thermo.txt'))
        # Populate the main primary thermo library with this thermo data
        # This will overwrite keys (but not values), so the order that the
        # seed mechanisms are loaded matters!
        for key, value in d.iteritems():
            thermo.data.thermoDatabase.primaryDatabase.dictionary[key] = value
        for key, value in thermoData.library.iteritems():
            thermo.data.thermoDatabase.primaryDatabase.library[key] = value

        # Create new species based on items in species.txt
        seedSpeciesDict = {}; seedSpeciesList = []
        for label, struct in d.iteritems():
            spec, isNew = species.makeNewSpecies(struct, label, reactive=True)
            seedSpeciesDict[label] = spec
            seedSpeciesList.append(spec)

        # Load the reactions from the file reaction.txt
        seedReactionList = []
        f = open(os.path.join(path, 'reactions.txt'), 'r')
        for line in f:
            line = data.removeCommentFromLine(line)
            line.strip()
            if len(line) > 0:
                items = line.split()
                if len(items) > 0:
                    rxn = items[0:-6]

                    # Extract reactants and products
                    if '<=>' in rxn: arrow = rxn.index('<=>')
                    elif '=>' in rxn: arrow = rxn.index('=>')
                    else: raise IOError('No arrow found in reaction equation from line %s' % line)
                    reactants = rxn[0:arrow:2]
                    products = rxn[arrow+1::2]

                    # Remove third body 'M' if present
                    thirdBody = False
                    if 'M' in reactants and 'M' in products:
                        thirdBody = True
                        reactants.remove('M')
                        products.remove('M')

                    # Convert strings to species objects
                    reactants = [seedSpeciesDict[r] for r in reactants]
                    products = [seedSpeciesDict[r] for r in products]
                    reactants.sort()
                    products.sort()

                    # Process Arrhenius parameters
                    order = len(reactants)
                    if (thirdBody): order += 1
                    Aunits = 'cm^%i/(mol^%i*s)' % (3*(order-1), order-1)
                    A = float(pq.Quantity(float(items[-6]), Aunits).simplified)
                    n = float(items[-5])			# dimensionless
                    Ea = float(pq.Quantity(float(items[-4]), 'cal/mol').simplified)
                    kin = [kinetics.model.ArrheniusModel(A=A, n=n, Ea=Ea)]

                    # Create reaction object and add to list
                    rxn = reaction.Reaction(id=0, reactants=reactants, products=products, family='seed', kinetics=kin, thirdBody=thirdBody)
                    rxn.reverse = reaction.Reaction(id=0, reactants=products, products=reactants, family='seed', kinetics=None, thirdBody=thirdBody)
                    rxn.reverse.reverse = rxn
                    reaction.processNewReaction(rxn)
                    seedReactionList.append(rxn)

        f.close()

        # Add species to core
        for spec in seedSpeciesList:
            self.addSpeciesToCore(spec)
        # Add reactions to core
        for rxn in seedReactionList:
            self.addReactionToCore(rxn)

################################################################################

class TemperatureModel:
    """
    Represent a temperature profile. Currently the only implemented model is
    isothermal (constant temperature).
    """

    def __init__(self):
        self.type = ''
        self.temperatures = []

    def isIsothermal(self):
        return self.type == 'isothermal'

    def setIsothermal(self, temperature):
        self.type = 'isothermal'
        self.temperatures = [ [0.0, temperature] ]

    def getTemperature(self, time=None):
        if self.isIsothermal():
            return self.temperatures[0][1]
        else:
            return None

    def __str__(self):
        string = 'Temperature model: ' + self.type + ' '
        if self.isIsothermal():
            string += str(self.getTemperature(0))
        return string

################################################################################

class PressureModel:
    """
    Represent a pressure profile. Currently the only implemented model is
    isobaric (constant pressure).
    """

    def __init__(self):
        self.type = ''
        self.pressures = []

    def isIsobaric(self):
        return self.type == 'isobaric'

    def setIsobaric(self, pressure):
        self.type = 'isobaric'
        self.pressures = [ [0.0, pressure] ]

    def getPressure(self, time=None):
        if self.isIsobaric():
            return self.pressures[0][1]
        else:
            return None

    def __str__(self):
        string = 'Pressure model: ' + self.type + ' '
        if self.isIsobaric():
            string += str(self.getPressure(0))
        return string

################################################################################

class IdealGas:
    """
    An equation of state based on the ideal gas approximation

    .. math::

        f(P, V, T, \\mathbf{N}) = NRT - PV

    where :math:`N \\equiv \\sum_i N_i` is the total number of moles.

    The ideal gas approximation is generally valid for gases at low pressures
    and moderate tempertaures; it does not predict the gas-liquid phase
    transition and is not applicable to liquids.
    """

    def getTemperature(self, P, V, N):
        """
        Return the temperature associated with pressure `P`, volume `V`, and
        numbers of moles `N`.
        """
        return P * V / (sum(N) * constants.R)

    def getPressure(self, T, V, N):
        """
        Return the pressure associated with temperature `T`, volume `V`, and
        numbers of moles `N`.
        """
        return sum(N) * constants.R * T / V

    def getVolume(self, T, P, N):
        """
        Return the volume associated with temperature `T`, pressure `P`, and
        numbers of moles `N` (which may be a list, in which case it's summed).
        """
        try:
            N = sum(N)
        except TypeError: #can't iterate; N probably a float not a list
            pass
        return N * constants.R * T / P

    def getdPdV(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dP}{dV}\\big|_{T,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return (-P/V)

    def getdPdT(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dP}{dT}\\big|_{V,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return (P/T)

    def getdVdT(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dV}{dT}\\big|_{P,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return (V/T)

    def getdVdP(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dV}{dP}\\big|_{T,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return 1.0 / self.getdPdV(P, V, T, N)

    def getdTdP(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dT}{dP}\\big|_{V,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return 1.0 / self.getdPdT(P, V, T, N)

    def getdTdV(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dT}{dV}\\big|_{P,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return 1.0 / self.getdVdT(P, V, T, N)

    def getdPdNi(self, P, V, T, N, i):
        """
        Return the derivative :math:`\\frac{dP}{dN_i}\\big|_{T, V,\mathbf{N}_{j \\ne i}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`. The final parameter `i` is used to determine which
        species to use; if `N` is a list, then `i` is an index, while if `N` is
        a dictionary, `i` is a key.
        """
        if type(N) is dict: return (P/numpy.sum(N.values()))
        else: return (P/numpy.sum(N))

    def getdVdNi(self, P, V, T, N, i):
        """
        Return the derivative :math:`\\frac{dV}{dN_i}\\big|_{T, P,\mathbf{N}_{j \\ne i}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`. The final parameter `i` is the index of the
        species of interest, corresponding to an index into the list `N`.
        """
        if type(N) is dict: return (V/numpy.sum(N.values()))
        else: return (V/numpy.sum(N))

    def getdTdNi(self, P, V, T, N, i):
        """
        Return the derivative :math:`\\frac{dT}{dN_i}\\big|_{P, V,\mathbf{N}_{j \\ne i}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`. The final parameter `i` is the index of the
        species of interest, corresponding to an index into the list `N`.
        """
        if type(N) is dict: return (-T/numpy.sum(N.values()))
        else: return (-T/numpy.sum(N))

################################################################################

class IncompressibleLiquid:
    """
    An equation of state for incompressible liquids

    .. math:: f(P, V, T, \\mathbf{N}) = ?

    where :math:`N \\equiv \\sum_i N_i` is the total number of moles.

    Initialise with keyword arguments::
        il = IncompressibleLiquid(T=298, P=1E5, V=, N=, Vmol=)
    """
    def __init__(self, T=None, P=None, V=None, N=None, Vmol=None):
        self.T = T
        self.P = P
        self.V = V
        self.N = N
        self.Vmol = Vmol # Molar volume

    def getTemperature(self, P, V, N):
        """
        Return the temperature associated with pressure `P`, volume `V`, and
        numbers of moles `N`.
        """
        if self.T:
            return self.T
        else:
            raise Exception("I'm a liquid, and can't deduce T from P,V,N.")

    def getPressure(self, T, V, N):
        """
        Return the pressure associated with temperature `T`, volume `V`, and
        numbers of moles `N`.
        """
        if self.P:
            return self.P
        else:
            raise Exception("I'm a liquid, and can't deduce P from T,V,N.")

    def getVolume(self, T, P, N):
        """
        Return the volume associated with temperature `T`, pressure `P`, and
        numbers of moles `N` (which may be a list, in which case it's summed).
        """
        if self.V:
            logging.debug("Using explicit volume.")
            return self.V
        try:
            N = sum(N)
        except TypeError: #can't iterate; N probably a float not a list
            pass
        if self.Vmol:
            return N * self.Vmol
        else:
            raise Exception("I'm a liquid with unknown molarVolume, and can't deduce V from T,P,N.")

    def getdPdV(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dP}{dV}\\big|_{T,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return  0

    def getdPdT(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dP}{dT}\\big|_{V,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return 0

    def getdVdT(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dV}{dT}\\big|_{P,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return 0

    def getdVdP(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dV}{dP}\\big|_{T,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return 0

    def getdTdP(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dT}{dP}\\bigg|_{V,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return 0

    def getdTdV(self, P, V, T, N):
        """
        Return the derivative :math:`\\frac{dT}{dV}\\big|_{P,\mathbf{N}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`.
        """
        return 0

    def getdPdNi(self, P, V, T, N, i):
        """
        Return the derivative :math:`\\frac{dP}{dN_i}\\big|_{T, V,\mathbf{N}_{j \\ne i}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`. The final parameter `i` is used to determine which
        species to use; if `N` is a list, then `i` is an index, while if `N` is
        a dictionary, `i` is a key.
        """
        return numpy.inf
        ### Warning: may be inconsistent with dVdNi and dVdP
        ## if dVdNi>0 and dVdP=0 then is'nt dPdNi = infinity ?

    def getdTdNi(self, P, V, T, N, i):
        """
        Return the derivative :math:`\\frac{dT}{dN_i}\\big|_{P, V,\mathbf{N}_{j \\ne i}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`. The final parameter `i` is the index of the
        species of interest, corresponding to an index into the list `N`.
        """
        return 0

    def getdVdNi(self, P, V, T, N, i):
        """
        Return the derivative :math:`\\frac{dV}{dN_i}\\big|_{T, P,\mathbf{N}_{j \\ne i}}`
        evaluated at a given pressure `P`, volume `V`, temperature `T`, and
        numbers of moles `N`. The final parameter `i` is the index of the
        species of interest, corresponding to an index into the list `N`.

        For lack of better information,
        we assume that the partial molar volume of species `i`
        is equal to the average molar volume of the mixture as a whole.
        """

        if self.Vmol: # molar volume is set; assume it's the same for all components, and use it
            return self.Vmol

        # Else assume that the partial molar volume of species i
        # is equal to the average molar volume of all species
        if type(N) is dict: return (V/numpy.sum(N.values()))
        else: return (V/numpy.sum(N))



################################################################################

class InvalidReactionSystemException(Exception):
    """
    An exception used when an invalid reaction system is encountered.
    """

    def __init__(self, label):
        self.label = label

    def __str__(self):
        return 'Invalid reaction system: ' + self.label

################################################################################

class ReactionSystem:
    """
    Represent a generic reaction system, e.g. a chemical reactor. A reaction
    system is defined by a temperature model `temperatureModel`, a pressure
    model `pressureModel`, a volume model `volumeModel`, and a dictionary of
    initial and constant concentrations `initialConcentration`. Only two of
    `temperatureModel`, `pressureModel`, and `volumeModel` are independent; the
    remaining one must be set to :data:`None`.

    Each RMG job can handle multiple reaction systems; the resulting model
    will generally be the union of the models that would have been generated
    via individual RMG jobs, and will therefore be valid across all reaction
    systems provided.
    """

    def __init__(self, temperatureModel=None, pressureModel=None,
                 volumeModel=None, initialConcentration=None):
        self.setModels(temperatureModel, pressureModel, volumeModel)
        self.initialConcentration = initialConcentration or {}

    def setModels(self, temperatureModel, pressureModel, volumeModel):
        """
        Set any two of the reactor's `temperatureModel`, `pressureModel` or
        `volumeModel`. Attempting to set all three to non-None will cause an
        :class:`InvalidReactorModelException` to be raised.
        """
        # Fail if all three models are specified
        if temperatureModel is not None and pressureModel is not None and volumeModel is not None:
            raise InvalidReactionSystemException('Attempted to specify temperature, pressure, and volume models; can only specify two of these at a time.')
        # Otherwise set models
        self.temperatureModel = temperatureModel
        self.pressureModel = pressureModel
        self.volumeModel = volumeModel

################################################################################

class TerminationTime:
    """
    Represent a time at which the simulation should be terminated. This class
    has one attribute: the termination `time` in seconds.
    """

    def __init__(self, time=0.0):
        self.time = time

################################################################################

class TerminationConversion:
    """
    Represent a conversion at which the simulation should be terminated. This
    class has two attributes: the `species` to monitor and the fractional
    `conversion` at which to terminate.
    """

    def __init__(self, spec=None, conv=0.0):
        self.species = spec
        self.conversion = conv
